import {
  Color,
  FileLoader,
  HemisphereLight,
  InstancedBufferAttribute,
  LineBasicMaterial,
  LinearEncoding,
  LinearToneMapping,
  Loader,
  Material,
  MaterialLoader,
  MathUtils,
  Matrix3,
  Matrix4,
  MeshBasicMaterial,
  MeshPhysicalMaterial,
  MeshStandardMaterial,
  ObjectLoader,
  ObjectSpaceNormalMap,
  PointLight,
  PointsMaterial,
  REVISION,
  ShaderMaterial,
  SpriteMaterial,
  TangentSpaceNormalMap,
  Vector2,
  Vector3,
  Vector4,
  __publicField,
  sRGBEncoding
} from "./chunk-NDIKOADX.js";

// node_modules/three/examples/jsm/nodes/core/constants.js
var NodeShaderStage = {
  Vertex: "vertex",
  Fragment: "fragment"
};
var NodeUpdateType = {
  None: "none",
  Frame: "frame",
  Object: "object"
};
var NodeType = {
  Boolean: "bool",
  Integer: "int",
  Float: "float",
  Vector2: "vec2",
  Vector3: "vec3",
  Vector4: "vec4",
  Matrix3: "mat3",
  Matrix4: "mat4"
};

// node_modules/three/examples/jsm/nodes/core/NodeUtils.js
var getNodesKeys = (object) => {
  const props = [];
  for (const name in object) {
    const value = object[name];
    if (value && value.isNode === true) {
      props.push(name);
    }
  }
  return props;
};
var getValueType = (value) => {
  if (typeof value === "number") {
    return "float";
  } else if (typeof value === "boolean") {
    return "bool";
  } else if ((value == null ? void 0 : value.isVector2) === true) {
    return "vec2";
  } else if ((value == null ? void 0 : value.isVector3) === true) {
    return "vec3";
  } else if ((value == null ? void 0 : value.isVector4) === true) {
    return "vec4";
  } else if ((value == null ? void 0 : value.isMatrix3) === true) {
    return "mat3";
  } else if ((value == null ? void 0 : value.isMatrix4) === true) {
    return "mat4";
  } else if ((value == null ? void 0 : value.isColor) === true) {
    return "color";
  }
  return null;
};
var getValueFromType = (type, ...params) => {
  const last4 = type == null ? void 0 : type.slice(-4);
  if (type === "color") {
    return new Color(...params);
  } else if (last4 === "vec2") {
    return new Vector2(...params);
  } else if (last4 === "vec3") {
    return new Vector3(...params);
  } else if (last4 === "vec4") {
    return new Vector4(...params);
  } else if (last4 === "mat3") {
    return new Matrix3(...params);
  } else if (last4 === "mat4") {
    return new Matrix4(...params);
  } else if (type === "bool") {
    return false;
  } else if (type === "float" || type === "int" || type === "uint") {
    return 0;
  }
  return null;
};

// node_modules/three/examples/jsm/nodes/core/Node.js
var _nodeId = 0;
var Node = class {
  constructor(nodeType = null) {
    this.isNode = true;
    this.nodeType = nodeType;
    this.updateType = NodeUpdateType.None;
    this.uuid = MathUtils.generateUUID();
    Object.defineProperty(this, "id", { value: _nodeId++ });
  }
  get type() {
    return this.constructor.name;
  }
  getChildren() {
    const children = [];
    for (const property2 in this) {
      const object = this[property2];
      if (Array.isArray(object) === true) {
        for (const child of object) {
          if ((child == null ? void 0 : child.isNode) === true) {
            children.push(child);
          }
        }
      } else if ((object == null ? void 0 : object.isNode) === true) {
        children.push(object);
      }
    }
    return children;
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getNodeType() {
    return this.nodeType;
  }
  getConstructHash() {
    return this.uuid;
  }
  getReference(builder) {
    const hash = this.getHash(builder);
    const nodeFromHash = builder.getNodeFromHash(hash);
    return nodeFromHash || this;
  }
  construct(builder) {
    const nodeProperties = builder.getNodeProperties(this);
    for (const childNode of this.getChildren()) {
      nodeProperties["_node" + childNode.id] = childNode;
    }
    return null;
  }
  analyze(builder) {
    const nodeData = builder.getDataFromNode(this);
    nodeData.dependenciesCount = nodeData.dependenciesCount === void 0 ? 1 : nodeData.dependenciesCount + 1;
    if (nodeData.dependenciesCount === 1) {
      const nodeProperties = builder.getNodeProperties(this);
      for (const childNode of Object.values(nodeProperties)) {
        if ((childNode == null ? void 0 : childNode.isNode) === true) {
          childNode.build(builder);
        }
      }
    }
  }
  generate(builder, output) {
    const { outputNode } = builder.getNodeProperties(this);
    if ((outputNode == null ? void 0 : outputNode.isNode) === true) {
      return outputNode.build(builder, output);
    }
  }
  update() {
    console.warn("Abstract function.");
  }
  build(builder, output = null) {
    const refNode = this.getReference(builder);
    if (this !== refNode) {
      return refNode.build(builder, output);
    }
    builder.addNode(this);
    builder.addStack(this);
    let result = null;
    const buildStage = builder.getBuildStage();
    if (buildStage === "construct") {
      const properties = builder.getNodeProperties(this);
      if (properties.initialized !== true || builder.context.tempRead === false) {
        properties.initialized = true;
        properties.outputNode = this.construct(builder);
        for (const childNode of Object.values(properties)) {
          if ((childNode == null ? void 0 : childNode.isNode) === true) {
            childNode.build(builder);
          }
        }
      }
    } else if (buildStage === "analyze") {
      this.analyze(builder);
    } else if (buildStage === "generate") {
      const isGenerateOnce = this.generate.length === 1;
      if (isGenerateOnce) {
        const type = this.getNodeType(builder);
        const nodeData = builder.getDataFromNode(this);
        result = nodeData.snippet;
        if (result === void 0) {
          result = this.generate(builder) || "";
          nodeData.snippet = result;
        }
        result = builder.format(result, type, output);
      } else {
        result = this.generate(builder, output) || "";
      }
    }
    builder.removeStack(this);
    return result;
  }
  serialize(json) {
    const nodeKeys = getNodesKeys(this);
    if (nodeKeys.length > 0) {
      const inputNodes = {};
      for (const property2 of nodeKeys) {
        inputNodes[property2] = this[property2].toJSON(json.meta).uuid;
      }
      json.inputNodes = inputNodes;
    }
  }
  deserialize(json) {
    if (json.inputNodes !== void 0) {
      const nodes = json.meta.nodes;
      for (const property2 in json.inputNodes) {
        const uuid = json.inputNodes[property2];
        this[property2] = nodes[uuid];
      }
    }
  }
  toJSON(meta) {
    const { uuid, type } = this;
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    let data = meta.nodes[uuid];
    if (data === void 0) {
      data = {
        uuid,
        type,
        meta,
        metadata: {
          version: 4.5,
          type: "Node",
          generator: "Node.toJSON"
        }
      };
      meta.nodes[data.uuid] = data;
      this.serialize(data);
      delete data.meta;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
};
var Node_default = Node;

// node_modules/three/examples/jsm/nodes/core/InputNode.js
var InputNode = class extends Node_default {
  constructor(value, nodeType = null) {
    super(nodeType);
    this.isInputNode = true;
    this.value = value;
  }
  getNodeType() {
    if (this.nodeType === null) {
      return getValueType(this.value);
    }
    return this.nodeType;
  }
  getInputType(builder) {
    return this.getNodeType(builder);
  }
  serialize(data) {
    var _a, _b;
    super.serialize(data);
    data.value = ((_b = (_a = this.value) == null ? void 0 : _a.toArray) == null ? void 0 : _b.call(_a)) || this.value;
    data.valueType = getValueType(this.value);
    data.nodeType = this.nodeType;
  }
  deserialize(data) {
    var _a, _b;
    super.deserialize(data);
    this.nodeType = data.nodeType;
    this.value = getValueFromType(data.valueType);
    this.value = ((_b = (_a = this.value) == null ? void 0 : _a.fromArray) == null ? void 0 : _b.call(_a, data.value)) || data.value;
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var InputNode_default = InputNode;

// node_modules/three/examples/jsm/nodes/core/UniformNode.js
var UniformNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isUniformNode = true;
  }
  getUniformHash(builder) {
    return this.getHash(builder);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const hash = this.getUniformHash(builder);
    let sharedNode = builder.getNodeFromHash(hash);
    if (sharedNode === void 0) {
      builder.setHashNode(this, hash);
      sharedNode = this;
    }
    const sharedNodeType = sharedNode.getInputType(builder);
    const nodeUniform = builder.getUniformFromNode(sharedNode, builder.shaderStage, sharedNodeType);
    const propertyName = builder.getPropertyName(nodeUniform);
    return builder.format(propertyName, type, output);
  }
};
var UniformNode_default = UniformNode;

// node_modules/three/examples/jsm/nodes/core/ArrayUniformNode.js
var ArrayUniformNode = class extends UniformNode_default {
  constructor(nodes = []) {
    super();
    this.isArrayUniformNode = true;
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return this.nodes[0].getNodeType(builder);
  }
};
var ArrayUniformNode_default = ArrayUniformNode;

// node_modules/three/examples/jsm/nodes/core/VaryingNode.js
var VaryingNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const node = this.node;
    const name = this.name;
    const nodeVarying = builder.getVaryingFromNode(this, type);
    if (name !== null) {
      nodeVarying.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVarying, NodeShaderStage.Vertex);
    builder.flowNodeFromShaderStage(NodeShaderStage.Vertex, node, type, propertyName);
    return builder.getPropertyName(nodeVarying);
  }
};
var VaryingNode_default = VaryingNode;

// node_modules/three/examples/jsm/nodes/core/AttributeNode.js
var AttributeNode = class extends Node_default {
  constructor(attributeName, nodeType = null) {
    super(nodeType);
    this._attributeName = attributeName;
  }
  getHash(builder) {
    return this.getAttributeName(builder);
  }
  getNodeType(builder) {
    let nodeType = super.getNodeType(builder);
    if (nodeType === null) {
      const attributeName = this.getAttributeName(builder);
      const attribute2 = builder.geometry.getAttribute(attributeName);
      nodeType = builder.getTypeFromLength(attribute2.itemSize);
    }
    return nodeType;
  }
  setAttributeName(attributeName) {
    this._attributeName = attributeName;
    return this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(builder) {
    const attribute2 = builder.getAttribute(this.getAttributeName(builder), this.getNodeType(builder));
    if (builder.isShaderStage("vertex")) {
      return attribute2.name;
    } else {
      const nodeVarying = new VaryingNode_default(this);
      return nodeVarying.build(builder, attribute2.type);
    }
  }
};
var AttributeNode_default = AttributeNode;

// node_modules/three/examples/jsm/nodes/core/BypassNode.js
var BypassNode = class extends Node_default {
  constructor(returnNode, callNode) {
    super();
    this.isBypassNode = true;
    this.outputNode = returnNode;
    this.callNode = callNode;
  }
  getNodeType(builder) {
    return this.outputNode.getNodeType(builder);
  }
  generate(builder, output) {
    const snippet = this.callNode.build(builder, "void");
    if (snippet !== "") {
      builder.addFlowCode(snippet);
    }
    return this.outputNode.build(builder, output);
  }
};
var BypassNode_default = BypassNode;

// node_modules/three/examples/jsm/nodes/core/CodeNode.js
var CodeNode = class extends Node_default {
  constructor(code2 = "", nodeType = "code") {
    super(nodeType);
    this.isCodeNode = true;
    this.code = code2;
    this._includes = [];
  }
  setIncludes(includes) {
    this._includes = includes;
    return this;
  }
  getIncludes() {
    return this._includes;
  }
  generate(builder) {
    const includes = this.getIncludes(builder);
    for (const include of includes) {
      include.build(builder);
    }
    const nodeCode = builder.getCodeFromNode(this, this.getNodeType(builder));
    nodeCode.code = this.code;
    return nodeCode.code;
  }
};
var CodeNode_default = CodeNode;

// node_modules/three/examples/jsm/nodes/core/ConstNode.js
var ConstNode = class extends InputNode_default {
  constructor(value, nodeType = null) {
    super(value, nodeType);
    this.isConstNode = true;
  }
  generateConst(builder) {
    return builder.getConst(this.getNodeType(builder), this.value);
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    return builder.format(this.generateConst(builder), type, output);
  }
};
var ConstNode_default = ConstNode;

// node_modules/three/examples/jsm/nodes/core/ContextNode.js
var ContextNode = class extends Node_default {
  constructor(node, context2 = {}) {
    super();
    this.isContextNode = true;
    this.node = node;
    this.context = context2;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  construct(builder) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const node = this.node.build(builder);
    builder.setContext(previousContext);
    return node;
  }
  generate(builder, output) {
    const previousContext = builder.getContext();
    builder.setContext({ ...builder.context, ...this.context });
    const snippet = this.node.build(builder, output);
    builder.setContext(previousContext);
    return snippet;
  }
};
var ContextNode_default = ContextNode;

// node_modules/three/examples/jsm/nodes/core/TempNode.js
var TempNode = class extends Node_default {
  constructor(type) {
    super(type);
    this.isTempNode = true;
  }
  build(builder, output) {
    const buildStage = builder.getBuildStage();
    if (buildStage === "generate") {
      const type = builder.getVectorType(this.getNodeType(builder, output));
      const nodeData = builder.getDataFromNode(this);
      if (builder.context.tempRead !== false && nodeData.propertyName !== void 0) {
        return builder.format(nodeData.propertyName, type, output);
      } else if (builder.context.tempWrite !== false && type !== "void " && output !== "void" && nodeData.dependenciesCount > 1) {
        const snippet = super.build(builder, type);
        const nodeVar = builder.getVarFromNode(this, type);
        const propertyName = builder.getPropertyName(nodeVar);
        builder.addFlowCode(`${propertyName} = ${snippet}`);
        nodeData.snippet = snippet;
        nodeData.propertyName = propertyName;
        return builder.format(nodeData.propertyName, type, output);
      }
    }
    return super.build(builder, output);
  }
};
var TempNode_default = TempNode;

// node_modules/three/examples/jsm/nodes/core/ExpressionNode.js
var ExpressionNode = class extends TempNode_default {
  constructor(snipped = "", nodeType = "void") {
    super(nodeType);
    this.snipped = snipped;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const snipped = this.snipped;
    if (type === "void") {
      builder.addFlowCode(snipped);
    } else {
      return `( ${snipped} )`;
    }
  }
};
var ExpressionNode_default = ExpressionNode;

// node_modules/three/examples/jsm/nodes/core/FunctionCallNode.js
var FunctionCallNode = class extends TempNode_default {
  constructor(functionNode = null, parameters = {}) {
    super();
    this.functionNode = functionNode;
    this.parameters = parameters;
  }
  setParameters(parameters) {
    this.parameters = parameters;
    return this;
  }
  getParameters() {
    return this.parameters;
  }
  getNodeType(builder) {
    return this.functionNode.getNodeType(builder);
  }
  generate(builder) {
    const params = [];
    const functionNode = this.functionNode;
    const inputs = functionNode.getInputs(builder);
    const parameters = this.parameters;
    for (const inputNode of inputs) {
      const node = parameters[inputNode.name];
      if (node !== void 0) {
        params.push(node.build(builder, inputNode.type));
      } else {
        throw new Error(`FunctionCallNode: Input '${inputNode.name}' not found in FunctionNode.`);
      }
    }
    const functionName = functionNode.build(builder, "property");
    return `${functionName}( ${params.join(", ")} )`;
  }
};
var FunctionCallNode_default = FunctionCallNode;

// node_modules/three/examples/jsm/nodes/core/FunctionNode.js
var FunctionNode = class extends CodeNode_default {
  constructor(code2 = "") {
    super(code2);
    this.keywords = {};
  }
  getNodeType(builder) {
    return this.getNodeFunction(builder).type;
  }
  getInputs(builder) {
    return this.getNodeFunction(builder).inputs;
  }
  getNodeFunction(builder) {
    const nodeData = builder.getDataFromNode(this);
    let nodeFunction = nodeData.nodeFunction;
    if (nodeFunction === void 0) {
      nodeFunction = builder.parser.parseFunction(this.code);
      nodeData.nodeFunction = nodeFunction;
    }
    return nodeFunction;
  }
  call(parameters = {}) {
    return new FunctionCallNode_default(this, parameters);
  }
  generate(builder, output) {
    super.generate(builder);
    const nodeFunction = this.getNodeFunction(builder);
    const name = nodeFunction.name;
    const type = nodeFunction.type;
    const nodeCode = builder.getCodeFromNode(this, type);
    if (name !== "") {
      nodeCode.name = name;
    }
    const propertyName = builder.getPropertyName(nodeCode);
    let code2 = this.getNodeFunction(builder).getCode(propertyName);
    const keywords = this.keywords;
    const keywordsProperties = Object.keys(keywords);
    if (keywordsProperties.length > 0) {
      for (const property2 of keywordsProperties) {
        const propertyRegExp = new RegExp(`\\b${property2}\\b`, "g");
        const nodeProperty = keywords[property2].build(builder, "property");
        code2 = code2.replace(propertyRegExp, nodeProperty);
      }
    }
    nodeCode.code = code2;
    if (output === "property") {
      return propertyName;
    } else {
      return builder.format(`${propertyName}()`, type, output);
    }
  }
};
var FunctionNode_default = FunctionNode;

// node_modules/three/examples/jsm/nodes/core/InstanceIndexNode.js
var InstanceIndexNode = class extends Node_default {
  constructor() {
    super("uint");
    this.isInstanceIndexNode = true;
  }
  generate(builder) {
    return builder.getInstanceIndex();
  }
};
var InstanceIndexNode_default = InstanceIndexNode;

// node_modules/three/examples/jsm/nodes/core/NodeAttribute.js
var NodeAttribute = class {
  constructor(name, type) {
    this.isNodeAttribute = true;
    this.name = name;
    this.type = type;
  }
};
var NodeAttribute_default = NodeAttribute;

// node_modules/three/examples/jsm/nodes/core/NodeUniform.js
var NodeUniform = class {
  constructor(name, type, node, needsUpdate = void 0) {
    this.isNodeUniform = true;
    this.name = name;
    this.type = type;
    this.node = node;
    this.needsUpdate = needsUpdate;
  }
  get value() {
    return this.node.value;
  }
  set value(val) {
    this.node.value = val;
  }
};
var NodeUniform_default = NodeUniform;

// node_modules/three/examples/jsm/nodes/core/NodeVarying.js
var NodeVarying = class {
  constructor(name, type) {
    this.isNodeVarying = true;
    this.name = name;
    this.type = type;
  }
};
var NodeVarying_default = NodeVarying;

// node_modules/three/examples/jsm/nodes/core/NodeVar.js
var NodeVar = class {
  constructor(name, type) {
    this.isNodeVar = true;
    this.name = name;
    this.type = type;
  }
};
var NodeVar_default = NodeVar;

// node_modules/three/examples/jsm/nodes/core/NodeCode.js
var NodeCode = class {
  constructor(name, type, code2 = "") {
    this.name = name;
    this.type = type;
    this.code = code2;
    Object.defineProperty(this, "isNodeCode", { value: true });
  }
};
var NodeCode_default = NodeCode;

// node_modules/three/examples/jsm/nodes/core/NodeKeywords.js
var NodeKeywords = class {
  constructor() {
    this.keywords = [];
    this.nodes = [];
    this.keywordsCallback = {};
  }
  getNode(name) {
    let node = this.nodes[name];
    if (node === void 0 && this.keywordsCallback[name] !== void 0) {
      node = this.keywordsCallback[name](name);
      this.nodes[name] = node;
    }
    return node;
  }
  addKeyword(name, callback) {
    this.keywords.push(name);
    this.keywordsCallback[name] = callback;
    return this;
  }
  parse(code2) {
    const keywordNames = this.keywords;
    const regExp = new RegExp(`\\b${keywordNames.join("\\b|\\b")}\\b`, "g");
    const codeKeywords = code2.match(regExp);
    const keywordNodes = [];
    if (codeKeywords !== null) {
      for (const keyword of codeKeywords) {
        const node = this.getNode(keyword);
        if (node !== void 0 && keywordNodes.indexOf(node) === -1) {
          keywordNodes.push(node);
        }
      }
    }
    return keywordNodes;
  }
  include(builder, code2) {
    const keywordNodes = this.parse(code2);
    for (const keywordNode of keywordNodes) {
      keywordNode.build(builder);
    }
  }
};
var NodeKeywords_default = NodeKeywords;

// node_modules/three/examples/jsm/nodes/core/NodeBuilder.js
var defaultShaderStages = ["fragment", "vertex"];
var shaderStages = [...defaultShaderStages, "compute"];
var vector = ["x", "y", "z", "w"];
var typeFromLength = /* @__PURE__ */ new Map();
typeFromLength.set(1, "float");
typeFromLength.set(2, "vec2");
typeFromLength.set(3, "vec3");
typeFromLength.set(4, "vec4");
typeFromLength.set(9, "mat3");
typeFromLength.set(16, "mat4");
var toFloat = (value) => {
  value = Number(value);
  return value + (value % 1 ? "" : ".0");
};
var NodeBuilder = class {
  constructor(object, renderer, parser) {
    this.object = object;
    this.material = object.material || null;
    this.geometry = object.geometry || null;
    this.renderer = renderer;
    this.parser = parser;
    this.nodes = [];
    this.updateNodes = [];
    this.hashNodes = {};
    this.scene = null;
    this.lightsNode = null;
    this.fogNode = null;
    this.vertexShader = null;
    this.fragmentShader = null;
    this.computeShader = null;
    this.flowNodes = { vertex: [], fragment: [], compute: [] };
    this.flowCode = { vertex: "", fragment: "", compute: [] };
    this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 };
    this.codes = { vertex: [], fragment: [], compute: [] };
    this.attributes = [];
    this.varyings = [];
    this.vars = { vertex: [], fragment: [], compute: [] };
    this.flow = { code: "" };
    this.stack = [];
    this.context = {
      keywords: new NodeKeywords_default(),
      material: object.material
    };
    this.nodesData = /* @__PURE__ */ new WeakMap();
    this.flowsData = /* @__PURE__ */ new WeakMap();
    this.shaderStage = null;
    this.buildStage = null;
  }
  get node() {
    return this.stack[this.stack.length - 1];
  }
  addStack(node) {
    this.stack.push(node);
  }
  removeStack(node) {
    const lastStack = this.stack.pop();
    if (lastStack !== node) {
      throw new Error("NodeBuilder: Invalid node stack!");
    }
  }
  setHashNode(node, hash) {
    this.hashNodes[hash] = node;
  }
  addNode(node) {
    if (this.nodes.indexOf(node) === -1) {
      const updateType = node.getUpdateType(this);
      if (updateType !== NodeUpdateType.None) {
        this.updateNodes.push(node);
      }
      this.nodes.push(node);
      this.setHashNode(node, node.getHash(this));
    }
  }
  getMethod(method) {
    return method;
  }
  getNodeFromHash(hash) {
    return this.hashNodes[hash];
  }
  addFlow(shaderStage, node) {
    this.flowNodes[shaderStage].push(node);
    return node;
  }
  setContext(context2) {
    this.context = context2;
  }
  getContext() {
    return this.context;
  }
  isAvailable() {
    return false;
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getTexture() {
    console.warn("Abstract function.");
  }
  getTextureLevel() {
    console.warn("Abstract function.");
  }
  getCubeTexture() {
    console.warn("Abstract function.");
  }
  getCubeTextureLevel() {
    console.warn("Abstract function.");
  }
  // @TODO: rename to .generateConst()
  getConst(type, value) {
    if (type === "float")
      return toFloat(value);
    if (type === "int")
      return `${Math.round(value)}`;
    if (type === "uint")
      return value >= 0 ? `${Math.round(value)}u` : "0u";
    if (type === "bool")
      return value ? "true" : "false";
    if (type === "color")
      return `${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;
    const typeLength = this.getTypeLength(type);
    const componentType = this.getComponentType(type);
    const getConst = (value2) => this.getConst(componentType, value2);
    if (typeLength === 2) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)} )`;
    } else if (typeLength === 3) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)} )`;
    } else if (typeLength === 4) {
      return `${this.getType(type)}( ${getConst(value.x)}, ${getConst(value.y)}, ${getConst(value.z)}, ${getConst(value.w)} )`;
    } else if (typeLength > 4) {
      return `${this.getType(type)}()`;
    }
    throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`);
  }
  getType(type) {
    return type;
  }
  generateMethod(method) {
    return method;
  }
  getAttribute(name, type) {
    const attributes = this.attributes;
    for (const attribute3 of attributes) {
      if (attribute3.name === name) {
        return attribute3;
      }
    }
    const attribute2 = new NodeAttribute_default(name, type);
    attributes.push(attribute2);
    return attribute2;
  }
  getPropertyName(node) {
    return node.name;
  }
  isVector(type) {
    return /vec\d/.test(type);
  }
  isMatrix(type) {
    return /mat\d/.test(type);
  }
  isReference(type) {
    return type === "void" || type === "property" || type === "sampler" || type === "texture" || type === "cubeTexture";
  }
  isShaderStage(shaderStage) {
    return this.shaderStage === shaderStage;
  }
  getTextureEncodingFromMap(map) {
    let encoding;
    if (map && map.isTexture) {
      encoding = map.encoding;
    } else if (map && map.isWebGLRenderTarget) {
      encoding = map.texture.encoding;
    } else {
      encoding = LinearEncoding;
    }
    return encoding;
  }
  getComponentType(type) {
    type = this.getVectorType(type);
    const componentType = /(b|i|u|)(vec|mat)([2-4])/.exec(type);
    if (componentType === null)
      return null;
    if (componentType[1] === "b")
      return "bool";
    if (componentType[1] === "i")
      return "int";
    if (componentType[1] === "u")
      return "uint";
    return "float";
  }
  getVectorType(type) {
    if (type === "color")
      return "vec3";
    if (type === "texture")
      return "vec4";
    return type;
  }
  getTypeFromLength(length2) {
    return typeFromLength.get(length2);
  }
  getTypeLength(type) {
    const vecType = this.getVectorType(type);
    const vecNum = /vec([2-4])/.exec(vecType);
    if (vecNum !== null)
      return Number(vecNum[1]);
    if (vecType === "float" || vecType === "bool" || vecType === "int" || vecType === "uint")
      return 1;
    if (/mat3/.test(type) === true)
      return 9;
    if (/mat4/.test(type) === true)
      return 16;
    return 0;
  }
  getVectorFromMatrix(type) {
    return type.replace("mat", "vec");
  }
  getDataFromNode(node, shaderStage = this.shaderStage) {
    let nodeData = this.nodesData.get(node);
    if (nodeData === void 0) {
      nodeData = { vertex: {}, fragment: {}, compute: {} };
      this.nodesData.set(node, nodeData);
    }
    return shaderStage !== null ? nodeData[shaderStage] : nodeData;
  }
  getNodeProperties(node, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(this, shaderStage);
    const constructHash = node.getConstructHash(this);
    nodeData.properties = nodeData.properties || {};
    nodeData.properties[constructHash] = nodeData.properties[constructHash] || { outputNode: null };
    return nodeData.properties[constructHash];
  }
  getUniformFromNode(node, shaderStage, type) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeUniform = nodeData.uniform;
    if (nodeUniform === void 0) {
      const index = this.uniforms.index++;
      nodeUniform = new NodeUniform_default("nodeUniform" + index, type, node);
      this.uniforms[shaderStage].push(nodeUniform);
      nodeData.uniform = nodeUniform;
    }
    return nodeUniform;
  }
  getVarFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node, shaderStage);
    let nodeVar = nodeData.variable;
    if (nodeVar === void 0) {
      const vars = this.vars[shaderStage];
      const index = vars.length;
      nodeVar = new NodeVar_default("nodeVar" + index, type);
      vars.push(nodeVar);
      nodeData.variable = nodeVar;
    }
    return nodeVar;
  }
  getVaryingFromNode(node, type) {
    const nodeData = this.getDataFromNode(node, null);
    let nodeVarying = nodeData.varying;
    if (nodeVarying === void 0) {
      const varyings = this.varyings;
      const index = varyings.length;
      nodeVarying = new NodeVarying_default("nodeVarying" + index, type);
      varyings.push(nodeVarying);
      nodeData.varying = nodeVarying;
    }
    return nodeVarying;
  }
  getCodeFromNode(node, type, shaderStage = this.shaderStage) {
    const nodeData = this.getDataFromNode(node);
    let nodeCode = nodeData.code;
    if (nodeCode === void 0) {
      const codes = this.codes[shaderStage];
      const index = codes.length;
      nodeCode = new NodeCode_default("nodeCode" + index, type);
      codes.push(nodeCode);
      nodeData.code = nodeCode;
    }
    return nodeCode;
  }
  addFlowCode(code2) {
    this.flow.code += code2;
  }
  getFlowData(node) {
    return this.flowsData.get(node);
  }
  flowNode(node) {
    const output = node.getNodeType(this);
    const flowData = this.flowChildNode(node, output);
    this.flowsData.set(node, flowData);
    return flowData;
  }
  flowChildNode(node, output = null) {
    const previousFlow = this.flow;
    const flow = {
      code: ""
    };
    this.flow = flow;
    flow.result = node.build(this, output);
    this.flow = previousFlow;
    return flow;
  }
  flowNodeFromShaderStage(shaderStage, node, output = null, propertyName = null) {
    const previousShaderStage = this.shaderStage;
    this.setShaderStage(shaderStage);
    const flowData = this.flowChildNode(node, output);
    if (propertyName !== null) {
      flowData.code += `${propertyName} = ${flowData.result};
	`;
    }
    this.flowCode[shaderStage] = this.flowCode[shaderStage] + flowData.code;
    this.setShaderStage(previousShaderStage);
    return flowData;
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVars(shaderStage) {
    let snippet = "";
    const vars = this.vars[shaderStage];
    for (const variable of vars) {
      snippet += `${variable.type} ${variable.name}; `;
    }
    return snippet;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(shaderStage) {
    const codes = this.codes[shaderStage];
    let code2 = "";
    for (const nodeCode of codes) {
      code2 += nodeCode.code + "\n";
    }
    return code2;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(shaderStage) {
    this.shaderStage = shaderStage;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(buildStage) {
    this.buildStage = buildStage;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    this.setBuildStage("construct");
    for (const shaderStage of shaderStages) {
      this.setShaderStage(shaderStage);
      const flowNodes = this.flowNodes[shaderStage];
      for (const node of flowNodes) {
        node.build(this);
      }
    }
    this.setBuildStage("analyze");
    for (const shaderStage of shaderStages) {
      this.setShaderStage(shaderStage);
      const flowNodes = this.flowNodes[shaderStage];
      for (const node of flowNodes) {
        node.build(this);
      }
    }
    this.setBuildStage("generate");
    if (this.context.vertex && this.context.vertex.isNode) {
      this.flowNodeFromShaderStage("vertex", this.context.vertex);
    }
    this.setBuildStage("generate");
    for (const shaderStage of shaderStages) {
      this.setShaderStage(shaderStage);
      const flowNodes = this.flowNodes[shaderStage];
      for (const node of flowNodes) {
        this.flowNode(node);
      }
    }
    this.setBuildStage(null);
    this.setShaderStage(null);
    this.buildCode();
    return this;
  }
  format(snippet, fromType2, toType) {
    fromType2 = this.getVectorType(fromType2);
    toType = this.getVectorType(toType);
    if (fromType2 === toType || toType === null || this.isReference(toType)) {
      return snippet;
    }
    const fromTypeLength = this.getTypeLength(fromType2);
    const toTypeLength = this.getTypeLength(toType);
    if (fromTypeLength > 4) {
      return snippet;
    }
    if (toTypeLength > 4 || toTypeLength === 0) {
      return snippet;
    }
    if (fromTypeLength === toTypeLength) {
      return `${this.getType(toType)}( ${snippet} )`;
    }
    if (fromTypeLength > toTypeLength) {
      return this.format(`${snippet}.${"xyz".slice(0, toTypeLength)}`, this.getTypeFromLength(toTypeLength), toType);
    }
    if (toTypeLength === 4) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType2, "vec3")}, 1.0 )`;
    }
    if (fromTypeLength === 2) {
      return `${this.getType(toType)}( ${this.format(snippet, fromType2, "vec2")}, 0.0 )`;
    }
    return `${this.getType(toType)}( ${snippet} )`;
  }
  getSignature() {
    return `// Three.js r${REVISION} - NodeMaterial System
`;
  }
};
var NodeBuilder_default = NodeBuilder;

// node_modules/three/examples/jsm/nodes/core/NodeFrame.js
var NodeFrame = class {
  constructor() {
    this.time = 0;
    this.deltaTime = 0;
    this.frameId = 0;
    this.startTime = null;
    this.updateMap = /* @__PURE__ */ new WeakMap();
    this.renderer = null;
    this.material = null;
    this.camera = null;
    this.object = null;
  }
  updateNode(node) {
    if (node.updateType === NodeUpdateType.Frame) {
      if (this.updateMap.get(node) !== this.frameId) {
        this.updateMap.set(node, this.frameId);
        node.update(this);
      }
    } else if (node.updateType === NodeUpdateType.Object) {
      node.update(this);
    }
  }
  update() {
    this.frameId++;
    if (this.lastTime === void 0)
      this.lastTime = performance.now();
    this.deltaTime = (performance.now() - this.lastTime) / 1e3;
    this.lastTime = performance.now();
    this.time += this.deltaTime;
  }
};
var NodeFrame_default = NodeFrame;

// node_modules/three/examples/jsm/nodes/core/NodeFunctionInput.js
var NodeFunctionInput = class {
  constructor(type, name, count = null, qualifier = "", isConst = false) {
    this.type = type;
    this.name = name;
    this.count = count;
    this.qualifier = qualifier;
    this.isConst = isConst;
  }
};
NodeFunctionInput.isNodeFunctionInput = true;
var NodeFunctionInput_default = NodeFunctionInput;

// node_modules/three/examples/jsm/nodes/core/PropertyNode.js
var PropertyNode = class extends Node_default {
  constructor(name = null, nodeType = "vec4") {
    super(nodeType);
    this.name = name;
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  generate(builder) {
    const nodeVary = builder.getVarFromNode(this, this.getNodeType(builder));
    const name = this.name;
    if (name !== null) {
      nodeVary.name = name;
    }
    return builder.getPropertyName(nodeVary);
  }
};
var PropertyNode_default = PropertyNode;

// node_modules/three/examples/jsm/nodes/math/OperatorNode.js
var OperatorNode = class _OperatorNode extends TempNode_default {
  constructor(op, aNode, bNode, ...params) {
    super();
    this.op = op;
    if (params.length > 0) {
      let finalBNode = bNode;
      for (let i = 0; i < params.length; i++) {
        finalBNode = new _OperatorNode(op, finalBNode, params[i]);
      }
      bNode = finalBNode;
    }
    this.aNode = aNode;
    this.bNode = bNode;
  }
  getNodeType(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const typeA = aNode.getNodeType(builder);
    const typeB = bNode.getNodeType(builder);
    if (typeA === "void" || typeB === "void") {
      return "void";
    } else if (op === "=" || op === "%") {
      return typeA;
    } else if (op === "&" || op === "|" || op === "^" || op === ">>" || op === "<<") {
      return "int";
    } else if (op === "==" || op === "&&" || op === "||" || op === "^^") {
      return "bool";
    } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
      const typeLength = builder.getTypeLength(output);
      return typeLength > 1 ? `bvec${typeLength}` : "bool";
    } else {
      if (typeA === "float" && builder.isMatrix(typeB)) {
        return typeB;
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        return builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        return builder.getVectorFromMatrix(typeB);
      } else if (builder.getTypeLength(typeB) > builder.getTypeLength(typeA)) {
        return typeB;
      }
      return typeA;
    }
  }
  generate(builder, output) {
    const op = this.op;
    const aNode = this.aNode;
    const bNode = this.bNode;
    const type = this.getNodeType(builder, output);
    let typeA = null;
    let typeB = null;
    if (type !== "void") {
      typeA = aNode.getNodeType(builder);
      typeB = bNode.getNodeType(builder);
      if (op === "=") {
        typeB = typeA;
      } else if (op === "<" || op === ">" || op === "<=" || op === ">=") {
        if (builder.isVector(typeA)) {
          typeB = typeA;
        } else {
          typeA = typeB = "float";
        }
      } else if (builder.isMatrix(typeA) && builder.isVector(typeB)) {
        typeB = builder.getVectorFromMatrix(typeA);
      } else if (builder.isVector(typeA) && builder.isMatrix(typeB)) {
        typeA = builder.getVectorFromMatrix(typeB);
      } else {
        typeA = typeB = type;
      }
    } else {
      typeA = typeB = type;
    }
    const a = aNode.build(builder, typeA);
    const b = bNode.build(builder, typeB);
    const outputLength = builder.getTypeLength(output);
    if (output !== "void") {
      if (op === "=") {
        builder.addFlowCode(`${a} ${this.op} ${b}`);
        return a;
      } else if (op === ">" && outputLength > 1) {
        return builder.format(`${builder.getMethod("greaterThan")}( ${a}, ${b} )`, type, output);
      } else if (op === "<=" && outputLength > 1) {
        return builder.format(`${builder.getMethod("lessThanEqual")}( ${a}, ${b} )`, type, output);
      } else {
        return builder.format(`( ${a} ${this.op} ${b} )`, type, output);
      }
    } else if (typeA !== "void") {
      return builder.format(`${a} ${this.op} ${b}`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.op = this.op;
  }
  deserialize(data) {
    super.deserialize(data);
    this.op = data.op;
  }
};
var OperatorNode_default = OperatorNode;

// node_modules/three/examples/jsm/nodes/core/VarNode.js
var VarNode = class extends Node_default {
  constructor(node, name = null) {
    super();
    this.node = node;
    this.name = name;
  }
  op(op, ...params) {
    this.node = new OperatorNode_default(op, this.node, ...params);
    return this;
  }
  assign(...params) {
    return this.op("=", ...params);
  }
  add(...params) {
    return this.op("+", ...params);
  }
  sub(...params) {
    return this.op("-", ...params);
  }
  mul(...params) {
    return this.op("*", ...params);
  }
  div(...params) {
    return this.op("/", ...params);
  }
  getHash(builder) {
    return this.name || super.getHash(builder);
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const node = this.node;
    const name = this.name;
    if (name === null && node.isTempNode === true) {
      return node.build(builder);
    }
    const type = builder.getVectorType(this.getNodeType(builder));
    const snippet = node.build(builder, type);
    const nodeVar = builder.getVarFromNode(this, type);
    if (name !== null) {
      nodeVar.name = name;
    }
    const propertyName = builder.getPropertyName(nodeVar);
    builder.addFlowCode(`${propertyName} = ${snippet}`);
    return propertyName;
  }
};
var VarNode_default = VarNode;

// node_modules/three/examples/jsm/nodes/accessors/BufferNode.js
var BufferNode = class extends UniformNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType);
    this.isBufferNode = true;
    this.bufferType = bufferType;
    this.bufferCount = bufferCount;
  }
  getInputType() {
    return "buffer";
  }
};
var BufferNode_default = BufferNode;

// node_modules/three/examples/jsm/nodes/accessors/Object3DNode.js
var _Object3DNode = class _Object3DNode extends Node_default {
  constructor(scope = _Object3DNode.VIEW_MATRIX, object3d = null) {
    super();
    this.scope = scope;
    this.object3d = object3d;
    this.updateType = NodeUpdateType.Object;
    this._uniformNode = new UniformNode_default(null);
  }
  getNodeType() {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      return "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      return "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION) {
      return "vec3";
    }
  }
  update(frame) {
    const object = this.object3d;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _Object3DNode.VIEW_MATRIX) {
      uniformNode.value = object.modelViewMatrix;
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      uniformNode.value = object.normalMatrix;
    } else if (scope === _Object3DNode.WORLD_MATRIX) {
      uniformNode.value = object.matrixWorld;
    } else if (scope === _Object3DNode.POSITION) {
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
    } else if (scope === _Object3DNode.VIEW_POSITION) {
      const camera = frame.camera;
      uniformNode.value = uniformNode.value || new Vector3();
      uniformNode.value.setFromMatrixPosition(object.matrixWorld);
      uniformNode.value.applyMatrix4(camera.matrixWorldInverse);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _Object3DNode.WORLD_MATRIX || scope === _Object3DNode.VIEW_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    } else if (scope === _Object3DNode.NORMAL_MATRIX) {
      this._uniformNode.nodeType = "mat3";
    } else if (scope === _Object3DNode.POSITION || scope === _Object3DNode.VIEW_POSITION) {
      this._uniformNode.nodeType = "vec3";
    }
    return this._uniformNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
__publicField(_Object3DNode, "VIEW_MATRIX", "viewMatrix");
__publicField(_Object3DNode, "NORMAL_MATRIX", "normalMatrix");
__publicField(_Object3DNode, "WORLD_MATRIX", "worldMatrix");
__publicField(_Object3DNode, "POSITION", "position");
__publicField(_Object3DNode, "VIEW_POSITION", "viewPosition");
var Object3DNode = _Object3DNode;
var Object3DNode_default = Object3DNode;

// node_modules/three/examples/jsm/nodes/accessors/CameraNode.js
var _CameraNode = class _CameraNode extends Object3DNode_default {
  constructor(scope = _CameraNode.POSITION) {
    super(scope);
  }
  getNodeType(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      return "mat4";
    }
    return super.getNodeType(builder);
  }
  update(frame) {
    const camera = frame.camera;
    const uniformNode = this._uniformNode;
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      uniformNode.value = camera.projectionMatrix;
    } else if (scope === _CameraNode.VIEW_MATRIX) {
      uniformNode.value = camera.matrixWorldInverse;
    } else {
      this.object3d = camera;
      super.update(frame);
    }
  }
  generate(builder) {
    const scope = this.scope;
    if (scope === _CameraNode.PROJECTION_MATRIX) {
      this._uniformNode.nodeType = "mat4";
    }
    return super.generate(builder);
  }
};
__publicField(_CameraNode, "PROJECTION_MATRIX", "projectionMatrix");
var CameraNode = _CameraNode;
var CameraNode_default = CameraNode;

// node_modules/three/examples/jsm/nodes/accessors/UVNode.js
var UVNode = class extends AttributeNode_default {
  constructor(index = 0) {
    super(null, "vec2");
    this.isUVNode = true;
    this.index = index;
  }
  getAttributeName() {
    const index = this.index;
    return "uv" + (index > 0 ? index + 1 : "");
  }
  serialize(data) {
    super.serialize(data);
    data.index = this.index;
  }
  deserialize(data) {
    super.deserialize(data);
    this.index = data.index;
  }
};
var UVNode_default = UVNode;

// node_modules/three/examples/jsm/nodes/accessors/TextureNode.js
var TextureNode = class extends UniformNode_default {
  constructor(value, uvNode = new UVNode_default(), levelNode = null) {
    super(value, "vec4");
    this.isTextureNode = true;
    this.uvNode = uvNode;
    this.levelNode = levelNode;
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getInputType() {
    return "texture";
  }
  generate(builder, output) {
    const texture2 = this.value;
    if (!texture2 || texture2.isTexture !== true) {
      throw new Error("TextureNode: Need a three.js texture.");
    }
    const textureProperty = super.generate(builder, "texture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0) {
        const uvSnippet = this.uvNode.build(builder, "vec2");
        const levelNode = this.levelNode;
        if (levelNode !== null) {
          const levelSnippet = levelNode.build(builder, "float");
          snippet = builder.getTextureLevel(textureProperty, uvSnippet, levelSnippet);
        } else {
          snippet = builder.getTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.value = this.value.toJSON(data.meta).uuid;
  }
  deserialize(data) {
    super.deserialize(data);
    this.value = data.meta.textures[data.value];
  }
};
var TextureNode_default = TextureNode;

// node_modules/three/examples/jsm/nodes/accessors/ReferenceNode.js
var ReferenceNode = class extends Node_default {
  constructor(property2, uniformType, object = null) {
    super();
    this.property = property2;
    this.uniformType = uniformType;
    this.object = object;
    this.node = null;
    this.updateType = NodeUpdateType.Object;
    this.setNodeType(uniformType);
  }
  setNodeType(uniformType) {
    this.node = new UniformNode_default(null, uniformType);
    this.nodeType = uniformType;
    if (uniformType === "color") {
      this.nodeType = "vec3";
    } else if (uniformType === "texture") {
      this.nodeType = "vec4";
    }
  }
  getNodeType() {
    return this.uniformType;
  }
  update(frame) {
    const object = this.object !== null ? this.object : frame.object;
    const value = object[this.property];
    this.node.value = value;
  }
  generate(builder) {
    return this.node.build(builder, this.getNodeType(builder));
  }
};
var ReferenceNode_default = ReferenceNode;

// node_modules/three/examples/jsm/nodes/accessors/MaterialReferenceNode.js
var MaterialReferenceNode = class extends ReferenceNode_default {
  constructor(property2, inputType, material = null) {
    super(property2, inputType, material);
    this.material = material;
  }
  update(frame) {
    this.object = this.material !== null ? this.material : frame.material;
    super.update(frame);
  }
};
var MaterialReferenceNode_default = MaterialReferenceNode;

// node_modules/three/examples/jsm/nodes/utils/SplitNode.js
var vectorComponents = "xyzw";
var SplitNode = class extends Node_default {
  constructor(node, components = "x") {
    super();
    this.node = node;
    this.components = components;
  }
  getVectorLength() {
    let vectorLength = this.components.length;
    for (const c of this.components) {
      vectorLength = Math.max(vector.indexOf(c) + 1, vectorLength);
    }
    return vectorLength;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.components.length);
  }
  generate(builder, output) {
    const node = this.node;
    const nodeTypeLength = builder.getTypeLength(node.getNodeType(builder));
    let snippet = null;
    if (nodeTypeLength > 1) {
      let type = null;
      const componentsLength = this.getVectorLength();
      if (componentsLength >= nodeTypeLength) {
        type = builder.getTypeFromLength(this.getVectorLength());
      }
      const nodeSnippet = node.build(builder, type);
      if (this.components.length === nodeTypeLength && this.components === vectorComponents.slice(0, this.components.length)) {
        snippet = builder.format(nodeSnippet, type, output);
      } else {
        snippet = builder.format(`${nodeSnippet}.${this.components}`, this.getNodeType(builder), output);
      }
    } else {
      snippet = node.build(builder, output);
    }
    return snippet;
  }
  serialize(data) {
    super.serialize(data);
    data.components = this.components;
  }
  deserialize(data) {
    super.deserialize(data);
    this.components = data.components;
  }
};
var SplitNode_default = SplitNode;

// node_modules/three/examples/jsm/nodes/accessors/MaterialNode.js
var _MaterialNode = class _MaterialNode extends Node_default {
  constructor(scope = _MaterialNode.COLOR) {
    super();
    this.scope = scope;
  }
  getNodeType(builder) {
    const scope = this.scope;
    const material = builder.context.material;
    if (scope === _MaterialNode.COLOR) {
      return material.map !== null ? "vec4" : "vec3";
    } else if (scope === _MaterialNode.OPACITY || scope === _MaterialNode.ROTATION) {
      return "float";
    } else if (scope === _MaterialNode.EMISSIVE) {
      return "vec3";
    } else if (scope === _MaterialNode.ROUGHNESS || scope === _MaterialNode.METALNESS) {
      return "float";
    }
  }
  generate(builder, output) {
    var _a, _b, _c, _d, _e;
    const material = builder.context.material;
    const scope = this.scope;
    let node = null;
    if (scope === _MaterialNode.ALPHA_TEST) {
      node = new MaterialReferenceNode_default("alphaTest", "float");
    } else if (scope === _MaterialNode.COLOR) {
      const colorNode = new MaterialReferenceNode_default("color", "color");
      if (((_a = material.map) == null ? void 0 : _a.isTexture) === true) {
        const map = new TextureNode_default(material.map);
        node = new OperatorNode_default("*", colorNode, map);
      } else {
        node = colorNode;
      }
    } else if (scope === _MaterialNode.OPACITY) {
      const opacityNode = new MaterialReferenceNode_default("opacity", "float");
      if (((_b = material.alphaMap) == null ? void 0 : _b.isTexture) === true) {
        node = new OperatorNode_default("*", opacityNode, new MaterialReferenceNode_default("alphaMap", "texture"));
      } else {
        node = opacityNode;
      }
    } else if (scope === _MaterialNode.ROUGHNESS) {
      const roughnessNode = new MaterialReferenceNode_default("roughness", "float");
      if (((_c = material.roughnessMap) == null ? void 0 : _c.isTexture) === true) {
        node = new OperatorNode_default("*", roughnessNode, new SplitNode_default(new TextureNode_default(material.roughnessMap), "g"));
      } else {
        node = roughnessNode;
      }
    } else if (scope === _MaterialNode.METALNESS) {
      const metalnessNode = new MaterialReferenceNode_default("metalness", "float");
      if (((_d = material.metalnessMap) == null ? void 0 : _d.isTexture) === true) {
        node = new OperatorNode_default("*", metalnessNode, new SplitNode_default(new TextureNode_default(material.metalnessMap), "b"));
      } else {
        node = metalnessNode;
      }
    } else if (scope === _MaterialNode.EMISSIVE) {
      const emissiveNode = new MaterialReferenceNode_default("emissive", "color");
      if (((_e = material.emissiveMap) == null ? void 0 : _e.isTexture) === true) {
        node = new OperatorNode_default("*", emissiveNode, new TextureNode_default(material.emissiveMap));
      } else {
        node = emissiveNode;
      }
    } else if (scope === _MaterialNode.ROTATION) {
      node = new MaterialReferenceNode_default("rotation", "float");
    } else {
      const outputType = this.getNodeType(builder);
      node = new MaterialReferenceNode_default(scope, outputType);
    }
    return node.build(builder, output);
  }
};
__publicField(_MaterialNode, "ALPHA_TEST", "alphaTest");
__publicField(_MaterialNode, "COLOR", "color");
__publicField(_MaterialNode, "OPACITY", "opacity");
__publicField(_MaterialNode, "ROUGHNESS", "roughness");
__publicField(_MaterialNode, "METALNESS", "metalness");
__publicField(_MaterialNode, "EMISSIVE", "emissive");
__publicField(_MaterialNode, "ROTATION", "rotation");
var MaterialNode = _MaterialNode;
var MaterialNode_default = MaterialNode;

// node_modules/three/examples/jsm/nodes/accessors/ModelNode.js
var ModelNode = class _ModelNode extends Object3DNode_default {
  constructor(scope = _ModelNode.VIEW_MATRIX) {
    super(scope);
  }
  update(frame) {
    this.object3d = frame.object;
    super.update(frame);
  }
};
var ModelNode_default = ModelNode;

// node_modules/three/examples/jsm/nodes/utils/JoinNode.js
var JoinNode = class extends Node_default {
  constructor(nodes = []) {
    super();
    this.nodes = nodes;
  }
  getNodeType(builder) {
    return builder.getTypeFromLength(this.nodes.reduce((count, cur) => count + builder.getTypeLength(cur.getNodeType(builder)), 0));
  }
  generate(builder, output) {
    const type = this.getNodeType(builder);
    const nodes = this.nodes;
    const snippetValues = [];
    for (const input of nodes) {
      const inputSnippet = input.build(builder);
      snippetValues.push(inputSnippet);
    }
    const snippet = `${builder.getType(type)}( ${snippetValues.join(", ")} )`;
    return builder.format(snippet, type, output);
  }
};
var JoinNode_default = JoinNode;

// node_modules/three/examples/jsm/nodes/math/MathNode.js
var _MathNode = class _MathNode extends TempNode_default {
  constructor(method, aNode, bNode = null, cNode = null) {
    super();
    this.method = method;
    this.aNode = aNode;
    this.bNode = bNode;
    this.cNode = cNode;
  }
  getInputType(builder) {
    const aType = this.aNode.getNodeType(builder);
    const bType = this.bNode ? this.bNode.getNodeType(builder) : null;
    const cType = this.cNode ? this.cNode.getNodeType(builder) : null;
    const aLen = builder.isMatrix(aType) ? 0 : builder.getTypeLength(aType);
    const bLen = builder.isMatrix(bType) ? 0 : builder.getTypeLength(bType);
    const cLen = builder.isMatrix(cType) ? 0 : builder.getTypeLength(cType);
    if (aLen > bLen && aLen > cLen) {
      return aType;
    } else if (bLen > cLen) {
      return bType;
    } else if (cLen > aLen) {
      return cType;
    }
    return aType;
  }
  getNodeType(builder) {
    const method = this.method;
    if (method === _MathNode.LENGTH || method === _MathNode.DISTANCE || method === _MathNode.DOT) {
      return "float";
    } else if (method === _MathNode.CROSS) {
      return "vec3";
    } else {
      return this.getInputType(builder);
    }
  }
  generate(builder, output) {
    const method = this.method;
    const type = this.getNodeType(builder);
    const inputType = this.getInputType(builder);
    const a = this.aNode;
    const b = this.bNode;
    const c = this.cNode;
    const isWebGL = builder.renderer.isWebGLRenderer === true;
    if (isWebGL && (method === _MathNode.DFDX || method === _MathNode.DFDY) && output === "vec3") {
      return new JoinNode_default([
        new _MathNode(method, new SplitNode_default(a, "x")),
        new _MathNode(method, new SplitNode_default(a, "y")),
        new _MathNode(method, new SplitNode_default(a, "z"))
      ]).build(builder);
    } else if (method === _MathNode.TRANSFORM_DIRECTION) {
      let tA = a;
      let tB = b;
      if (builder.isMatrix(tA.getNodeType(builder))) {
        tB = new ExpressionNode_default(`${builder.getType("vec4")}( ${tB.build(builder, "vec3")}, 0.0 )`, "vec4");
      } else {
        tA = new ExpressionNode_default(`${builder.getType("vec4")}( ${tA.build(builder, "vec3")}, 0.0 )`, "vec4");
      }
      const mulNode = new SplitNode_default(new OperatorNode_default("*", tA, tB), "xyz");
      return new _MathNode(_MathNode.NORMALIZE, mulNode).build(builder);
    } else if (method === _MathNode.SATURATE) {
      return builder.format(`clamp( ${a.build(builder, inputType)}, 0.0, 1.0 )`, type, output);
    } else if (method === _MathNode.NEGATE) {
      return builder.format("( -" + a.build(builder, inputType) + " )", type, output);
    } else if (method === _MathNode.INVERT) {
      return builder.format("( 1.0 - " + a.build(builder, inputType) + " )", type, output);
    } else {
      const params = [];
      if (method === _MathNode.CROSS) {
        params.push(
          a.build(builder, type),
          b.build(builder, type)
        );
      } else if (method === _MathNode.STEP) {
        params.push(
          a.build(builder, builder.getTypeLength(a.getNodeType(builder)) === 1 ? "float" : inputType),
          b.build(builder, inputType)
        );
      } else if (isWebGL && (method === _MathNode.MIN || method === _MathNode.MAX) || method === _MathNode.MOD) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, builder.getTypeLength(b.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else if (method === _MathNode.REFRACT) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, "float")
        );
      } else if (method === _MathNode.MIX) {
        params.push(
          a.build(builder, inputType),
          b.build(builder, inputType),
          c.build(builder, builder.getTypeLength(c.getNodeType(builder)) === 1 ? "float" : inputType)
        );
      } else {
        params.push(a.build(builder, inputType));
        if (c !== null) {
          params.push(b.build(builder, inputType), c.build(builder, inputType));
        } else if (b !== null) {
          params.push(b.build(builder, inputType));
        }
      }
      return builder.format(`${builder.getMethod(method)}( ${params.join(", ")} )`, type, output);
    }
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
// 1 input
__publicField(_MathNode, "RADIANS", "radians");
__publicField(_MathNode, "DEGREES", "degrees");
__publicField(_MathNode, "EXP", "exp");
__publicField(_MathNode, "EXP2", "exp2");
__publicField(_MathNode, "LOG", "log");
__publicField(_MathNode, "LOG2", "log2");
__publicField(_MathNode, "SQRT", "sqrt");
__publicField(_MathNode, "INVERSE_SQRT", "inversesqrt");
__publicField(_MathNode, "FLOOR", "floor");
__publicField(_MathNode, "CEIL", "ceil");
__publicField(_MathNode, "NORMALIZE", "normalize");
__publicField(_MathNode, "FRACT", "fract");
__publicField(_MathNode, "SIN", "sin");
__publicField(_MathNode, "COS", "cos");
__publicField(_MathNode, "TAN", "tan");
__publicField(_MathNode, "ASIN", "asin");
__publicField(_MathNode, "ACOS", "acos");
__publicField(_MathNode, "ATAN", "atan");
__publicField(_MathNode, "ABS", "abs");
__publicField(_MathNode, "SIGN", "sign");
__publicField(_MathNode, "LENGTH", "length");
__publicField(_MathNode, "NEGATE", "negate");
__publicField(_MathNode, "INVERT", "invert");
__publicField(_MathNode, "DFDX", "dFdx");
__publicField(_MathNode, "DFDY", "dFdy");
__publicField(_MathNode, "SATURATE", "saturate");
__publicField(_MathNode, "ROUND", "round");
// 2 inputs
__publicField(_MathNode, "ATAN2", "atan2");
__publicField(_MathNode, "MIN", "min");
__publicField(_MathNode, "MAX", "max");
__publicField(_MathNode, "MOD", "mod");
__publicField(_MathNode, "STEP", "step");
__publicField(_MathNode, "REFLECT", "reflect");
__publicField(_MathNode, "DISTANCE", "distance");
__publicField(_MathNode, "DOT", "dot");
__publicField(_MathNode, "CROSS", "cross");
__publicField(_MathNode, "POW", "pow");
__publicField(_MathNode, "TRANSFORM_DIRECTION", "transformDirection");
// 3 inputs
__publicField(_MathNode, "MIX", "mix");
__publicField(_MathNode, "CLAMP", "clamp");
__publicField(_MathNode, "REFRACT", "refract");
__publicField(_MathNode, "SMOOTHSTEP", "smoothstep");
__publicField(_MathNode, "FACEFORWARD", "faceforward");
var MathNode = _MathNode;
var MathNode_default = MathNode;

// node_modules/three/examples/jsm/nodes/accessors/PositionNode.js
var _PositionNode = class _PositionNode extends Node_default {
  constructor(scope = _PositionNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _PositionNode.GEOMETRY) {
      outputNode = new AttributeNode_default("position", "vec3");
    } else if (scope === _PositionNode.LOCAL) {
      outputNode = new VaryingNode_default(new _PositionNode(_PositionNode.GEOMETRY));
    } else if (scope === _PositionNode.WORLD) {
      const vertexPositionNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new ModelNode_default(ModelNode_default.WORLD_MATRIX), new _PositionNode(_PositionNode.LOCAL));
      outputNode = new VaryingNode_default(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW) {
      const vertexPositionNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.VIEW_MATRIX), new _PositionNode(_PositionNode.LOCAL));
      outputNode = new VaryingNode_default(vertexPositionNode);
    } else if (scope === _PositionNode.VIEW_DIRECTION) {
      const vertexPositionNode = new MathNode_default(MathNode_default.NEGATE, new _PositionNode(_PositionNode.VIEW));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexPositionNode));
    }
    return outputNode.build(builder, this.getNodeType(builder));
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
__publicField(_PositionNode, "GEOMETRY", "geometry");
__publicField(_PositionNode, "LOCAL", "local");
__publicField(_PositionNode, "WORLD", "world");
__publicField(_PositionNode, "VIEW", "view");
__publicField(_PositionNode, "VIEW_DIRECTION", "viewDirection");
var PositionNode = _PositionNode;
var PositionNode_default = PositionNode;

// node_modules/three/examples/jsm/nodes/accessors/ModelViewProjectionNode.js
var ModelViewProjectionNode = class extends Node_default {
  constructor(position = new PositionNode_default()) {
    super("vec4");
    this.position = position;
  }
  generate(builder) {
    const position = this.position;
    const mvpMatrix = new OperatorNode_default("*", new CameraNode_default(CameraNode_default.PROJECTION_MATRIX), new ModelNode_default(ModelNode_default.VIEW_MATRIX));
    const mvpNode = new OperatorNode_default("*", mvpMatrix, position);
    return mvpNode.build(builder);
  }
};
var ModelViewProjectionNode_default = ModelViewProjectionNode;

// node_modules/three/examples/jsm/nodes/accessors/NormalNode.js
var _NormalNode = class _NormalNode extends Node_default {
  constructor(scope = _NormalNode.LOCAL) {
    super("vec3");
    this.scope = scope;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(builder) {
    const scope = this.scope;
    let outputNode = null;
    if (scope === _NormalNode.GEOMETRY) {
      outputNode = new AttributeNode_default("normal", "vec3");
    } else if (scope === _NormalNode.LOCAL) {
      outputNode = new VaryingNode_default(new _NormalNode(_NormalNode.GEOMETRY));
    } else if (scope === _NormalNode.VIEW) {
      const vertexNormalNode = new OperatorNode_default("*", new ModelNode_default(ModelNode_default.NORMAL_MATRIX), new _NormalNode(_NormalNode.LOCAL));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexNormalNode));
    } else if (scope === _NormalNode.WORLD) {
      const vertexNormalNode = new MathNode_default(MathNode_default.TRANSFORM_DIRECTION, new _NormalNode(_NormalNode.VIEW), new CameraNode_default(CameraNode_default.VIEW_MATRIX));
      outputNode = new MathNode_default(MathNode_default.NORMALIZE, new VaryingNode_default(vertexNormalNode));
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
  }
};
__publicField(_NormalNode, "GEOMETRY", "geometry");
__publicField(_NormalNode, "LOCAL", "local");
__publicField(_NormalNode, "WORLD", "world");
__publicField(_NormalNode, "VIEW", "view");
var NormalNode = _NormalNode;
var NormalNode_default = NormalNode;

// node_modules/three/examples/jsm/nodes/accessors/PointUVNode.js
var PointUVNode = class extends Node_default {
  constructor() {
    super("vec2");
    this.isPointUVNode = true;
  }
  generate() {
    return "vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y )";
  }
};
var PointUVNode_default = PointUVNode;

// node_modules/three/examples/jsm/nodes/accessors/StorageBufferNode.js
var StorageBufferNode = class extends BufferNode_default {
  constructor(value, bufferType, bufferCount = 0) {
    super(value, bufferType, bufferCount);
    this.isStorageBufferNode = true;
  }
  getInputType() {
    return "storageBuffer";
  }
};
var StorageBufferNode_default = StorageBufferNode;

// node_modules/three/examples/jsm/nodes/accessors/UserDataNode.js
var UserDataNode = class extends ReferenceNode_default {
  constructor(property2, inputType, userData2 = null) {
    super(property2, inputType, userData2);
    this.userData = userData2;
  }
  update(frame) {
    this.object = this.userData !== null ? this.userData : frame.object.userData;
    super.update(frame);
  }
};
var UserDataNode_default = UserDataNode;

// node_modules/three/examples/jsm/nodes/display/FrontFacingNode.js
var FrontFacingNode = class extends Node_default {
  constructor() {
    super("bool");
    this.isFrontFacingNode = true;
  }
  generate(builder) {
    return builder.getFrontFacing();
  }
};
var FrontFacingNode_default = FrontFacingNode;

// node_modules/three/examples/jsm/nodes/gpgpu/ComputeNode.js
var ComputeNode = class extends Node_default {
  constructor(computeNode, count, workgroupSize = [64]) {
    super("void");
    this.isComputeNode = true;
    this.computeNode = computeNode;
    this.count = count;
    this.workgroupSize = workgroupSize;
    this.dispatchCount = 0;
    this.updateType = NodeUpdateType.Object;
    this.updateDispatchCount();
  }
  updateDispatchCount() {
    const { count, workgroupSize } = this;
    let size = workgroupSize[0];
    for (let i = 1; i < workgroupSize.length; i++)
      size *= workgroupSize[i];
    this.dispatchCount = Math.ceil(count / size);
  }
  onInit() {
  }
  update({ renderer }) {
    renderer.compute(this);
  }
  generate(builder) {
    const { shaderStage } = builder;
    if (shaderStage === "compute") {
      const snippet = this.computeNode.build(builder, "void");
      if (snippet !== "") {
        builder.addFlowCode(snippet);
      }
    }
  }
};
var ComputeNode_default = ComputeNode;

// node_modules/three/examples/jsm/nodes/math/CondNode.js
var CondNode = class extends Node_default {
  constructor(condNode, ifNode, elseNode) {
    super();
    this.condNode = condNode;
    this.ifNode = ifNode;
    this.elseNode = elseNode;
  }
  getNodeType(builder) {
    const ifType = this.ifNode.getNodeType(builder);
    const elseType = this.elseNode.getNodeType(builder);
    if (builder.getTypeLength(elseType) > builder.getTypeLength(ifType)) {
      return elseType;
    }
    return ifType;
  }
  generate(builder) {
    const type = this.getNodeType(builder);
    const context2 = { tempWrite: false };
    const nodeProperty = new PropertyNode_default(null, type).build(builder);
    const nodeSnippet = new ContextNode_default(
      this.condNode
      /*, context*/
    ).build(builder, "bool"), ifSnippet = new ContextNode_default(this.ifNode, context2).build(builder, type), elseSnippet = new ContextNode_default(this.elseNode, context2).build(builder, type);
    builder.addFlowCode(`if ( ${nodeSnippet} ) {

		${nodeProperty} = ${ifSnippet};

	} else {

		${nodeProperty} = ${elseSnippet};

	}`);
    return nodeProperty;
  }
};
var CondNode_default = CondNode;

// node_modules/three/examples/jsm/nodes/utils/ArrayElementNode.js
var ArrayElementNode = class extends Node_default {
  constructor(node, indexNode) {
    super();
    this.node = node;
    this.indexNode = indexNode;
  }
  getNodeType(builder) {
    return this.node.getNodeType(builder);
  }
  generate(builder) {
    const nodeSnippet = this.node.build(builder);
    const indexSnippet = this.indexNode.build(builder, "uint");
    return `${nodeSnippet}[ ${indexSnippet} ]`;
  }
};
var ArrayElementNode_default = ArrayElementNode;

// node_modules/three/examples/jsm/nodes/utils/ConvertNode.js
var ConvertNode = class extends Node_default {
  constructor(node, convertTo) {
    super();
    this.node = node;
    this.convertTo = convertTo;
  }
  getNodeType() {
    return this.convertTo;
  }
  generate(builder, output) {
    const convertTo = this.convertTo;
    const node = this.node;
    const type = this.getNodeType(builder);
    let snippet = null;
    if (builder.isReference(convertTo) === false) {
      const nodeSnippet = node.build(builder, convertTo);
      snippet = builder.format(nodeSnippet, type, convertTo);
    } else {
      snippet = node.build(builder, convertTo);
    }
    return builder.format(snippet, type, output);
  }
};
var ConvertNode_default = ConvertNode;

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNode.js
var shaderNodeHandler = {
  construct(NodeClosure, params) {
    const inputs = params.shift();
    return NodeClosure(nodeObjects(inputs), ...params);
  },
  get: function(node, prop) {
    if (typeof prop === "string" && node[prop] === void 0) {
      if (/^[xyzwrgbastpq]{1,4}$/.test(prop) === true) {
        prop = prop.replace(/r|s/g, "x").replace(/g|t/g, "y").replace(/b|p/g, "z").replace(/a|q/g, "w");
        return nodeObject(new SplitNode_default(node, prop));
      } else if (/^\d+$/.test(prop) === true) {
        return nodeObject(new ArrayElementNode_default(node, new ConstNode_default(Number(prop), "uint")));
      }
    }
    return node[prop];
  }
};
var nodeObjectsCacheMap = /* @__PURE__ */ new WeakMap();
var ShaderNodeObject = function(obj) {
  const type = typeof obj;
  if (type === "number" || type === "boolean") {
    return nodeObject(getAutoTypedConstNode(obj));
  } else if (type === "object") {
    if ((obj == null ? void 0 : obj.isNode) === true) {
      let nodeObject2 = nodeObjectsCacheMap.get(obj);
      if (nodeObject2 === void 0) {
        nodeObject2 = new Proxy(obj, shaderNodeHandler);
        nodeObjectsCacheMap.set(obj, nodeObject2);
        nodeObjectsCacheMap.set(nodeObject2, nodeObject2);
      }
      return nodeObject2;
    }
  }
  return obj;
};
var ShaderNodeObjects = function(objects) {
  for (const name in objects) {
    objects[name] = nodeObject(objects[name]);
  }
  return objects;
};
var ShaderNodeArray = function(array) {
  const len = array.length;
  for (let i = 0; i < len; i++) {
    array[i] = nodeObject(array[i]);
  }
  return array;
};
var ShaderNodeProxy = function(NodeClass, scope = null, factor = null) {
  if (scope === null) {
    return (...params) => {
      return nodeObject(new NodeClass(...nodeArray(params)));
    };
  } else if (factor === null) {
    return (...params) => {
      return nodeObject(new NodeClass(scope, ...nodeArray(params)));
    };
  } else {
    factor = nodeObject(factor);
    return (...params) => {
      return nodeObject(new NodeClass(scope, ...nodeArray(params), factor));
    };
  }
};
var ShaderNodeImmutable = function(NodeClass, ...params) {
  return nodeObject(new NodeClass(...nodeArray(params)));
};
var ShaderNodeScript = function(jsFunc) {
  const self = {
    build: (builder) => {
      self.call({}, builder);
      return "";
    },
    call: (inputs, builder) => {
      inputs = nodeObjects(inputs);
      return nodeObject(jsFunc(inputs, builder));
    }
  };
  return self;
};
var ShaderNode = new Proxy(ShaderNodeScript, shaderNodeHandler);
var nodeObject = (val) => (
  /* new */
  ShaderNodeObject(val)
);
var nodeObjects = (val) => new ShaderNodeObjects(val);
var nodeArray = (val) => new ShaderNodeArray(val);
var nodeProxy = (...val) => new ShaderNodeProxy(...val);
var nodeImmutable = (...val) => new ShaderNodeImmutable(...val);
var bools = [false, true];
var uints = [0, 1, 2, 3];
var ints = [-1, -2];
var floats = [0.5, 1.5, 1 / 3, 1e-6, 1e6, Math.PI, Math.PI * 2, 1 / Math.PI, 2 / Math.PI, 1 / (Math.PI * 2), Math.PI / 2];
var boolsCacheMap = /* @__PURE__ */ new Map();
for (const bool2 of bools)
  boolsCacheMap.set(bool2, new ConstNode_default(bool2));
var uintsCacheMap = /* @__PURE__ */ new Map();
for (const uint2 of uints)
  uintsCacheMap.set(uint2, new ConstNode_default(uint2, "uint"));
var intsCacheMap = new Map([...uintsCacheMap].map((el) => new ConstNode_default(el.value, "int")));
for (const int2 of ints)
  intsCacheMap.set(int2, new ConstNode_default(int2, "int"));
var floatsCacheMap = new Map([...intsCacheMap].map((el) => new ConstNode_default(el.value)));
for (const float2 of floats)
  floatsCacheMap.set(float2, new ConstNode_default(float2));
for (const float2 of floats)
  floatsCacheMap.set(-float2, new ConstNode_default(-float2));
var cacheMaps = { bool: boolsCacheMap, uint: uintsCacheMap, ints: intsCacheMap, float: floatsCacheMap };
var constNodesCacheMap = new Map([...boolsCacheMap, ...floatsCacheMap]);
var getAutoTypedConstNode = (value) => {
  if (constNodesCacheMap.has(value)) {
    return constNodesCacheMap.get(value);
  } else if (value.isNode === true) {
    return value;
  } else {
    return new ConstNode_default(value);
  }
};
var ConvertType = function(type, cacheMap = null) {
  return (...params) => {
    if (params.length === 0) {
      return nodeObject(new ConstNode_default(getValueFromType(type), type));
    } else {
      if (type === "color" && params[0].isNode !== true) {
        params = [getValueFromType(type, ...params)];
      }
      if (params.length === 1 && cacheMap !== null && cacheMap.has(params[0])) {
        return cacheMap.get(params[0]);
      }
      const nodes = params.map(getAutoTypedConstNode);
      if (nodes.length === 1) {
        return nodeObject(nodes[0].nodeType === type ? nodes[0] : new ConvertNode_default(nodes[0], type));
      }
      return nodeObject(new ConvertNode_default(new JoinNode_default(nodes), type));
    }
  };
};
var getConstNodeType = (value) => value.nodeType || value.convertTo || (typeof value === "string" ? value : null);

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNodeBaseElements.js
var color = new ConvertType("color");
var float = new ConvertType("float", cacheMaps.float);
var int = new ConvertType("int", cacheMaps.int);
var uint = new ConvertType("uint", cacheMaps.uint);
var bool = new ConvertType("bool", cacheMaps.bool);
var vec2 = new ConvertType("vec2");
var ivec2 = new ConvertType("ivec2");
var uvec2 = new ConvertType("uvec2");
var bvec2 = new ConvertType("bvec2");
var vec3 = new ConvertType("vec3");
var ivec3 = new ConvertType("ivec3");
var uvec3 = new ConvertType("uvec3");
var bvec3 = new ConvertType("bvec3");
var vec4 = new ConvertType("vec4");
var ivec4 = new ConvertType("ivec4");
var uvec4 = new ConvertType("uvec4");
var bvec4 = new ConvertType("bvec4");
var mat3 = new ConvertType("mat3");
var imat3 = new ConvertType("imat3");
var umat3 = new ConvertType("umat3");
var bmat3 = new ConvertType("bmat3");
var mat4 = new ConvertType("mat4");
var imat4 = new ConvertType("imat4");
var umat4 = new ConvertType("umat4");
var bmat4 = new ConvertType("bmat4");
var func = (code2) => {
  const node = nodeObject(new FunctionNode_default(code2));
  const call2 = node.call.bind(node);
  node.call = (params) => nodeObject(call2(params));
  return node;
};
var uniform = (nodeOrType) => {
  var _a;
  const nodeType = getConstNodeType(nodeOrType);
  const value = nodeOrType.isNode === true ? ((_a = nodeOrType.node) == null ? void 0 : _a.value) || nodeOrType.value : nodeOrType;
  return nodeObject(new UniformNode_default(value, nodeType));
};
var attribute = (name, nodeType) => nodeObject(new AttributeNode_default(name, nodeType));
var property = (name, nodeOrType) => nodeObject(new PropertyNode_default(name, getConstNodeType(nodeOrType)));
var bypass = nodeProxy(BypassNode_default);
var code = nodeProxy(CodeNode_default);
var context = nodeProxy(ContextNode_default);
var expression = nodeProxy(ExpressionNode_default);
var call = nodeProxy(FunctionCallNode_default);
var instanceIndex = nodeImmutable(InstanceIndexNode_default);
var label = nodeProxy(VarNode_default);
var temp = label;
var varying = nodeProxy(VaryingNode_default);
var buffer = (value, nodeOrType, count) => nodeObject(new BufferNode_default(value, getConstNodeType(nodeOrType), count));
var storage = (value, nodeOrType, count) => nodeObject(new StorageBufferNode_default(value, getConstNodeType(nodeOrType), count));
var cameraProjectionMatrix = nodeImmutable(CameraNode_default, CameraNode_default.PROJECTION_MATRIX);
var cameraViewMatrix = nodeImmutable(CameraNode_default, CameraNode_default.VIEW_MATRIX);
var cameraNormalMatrix = nodeImmutable(CameraNode_default, CameraNode_default.NORMAL_MATRIX);
var cameraWorldMatrix = nodeImmutable(CameraNode_default, CameraNode_default.WORLD_MATRIX);
var cameraPosition = nodeImmutable(CameraNode_default, CameraNode_default.POSITION);
var materialAlphaTest = nodeImmutable(MaterialNode_default, MaterialNode_default.ALPHA_TEST);
var materialColor = nodeImmutable(MaterialNode_default, MaterialNode_default.COLOR);
var materialEmissive = nodeImmutable(MaterialNode_default, MaterialNode_default.EMISSIVE);
var materialOpacity = nodeImmutable(MaterialNode_default, MaterialNode_default.OPACITY);
var materialRoughness = nodeImmutable(MaterialNode_default, MaterialNode_default.ROUGHNESS);
var materialMetalness = nodeImmutable(MaterialNode_default, MaterialNode_default.METALNESS);
var materialRotation = nodeImmutable(MaterialNode_default, MaterialNode_default.ROTATION);
var diffuseColor = nodeImmutable(PropertyNode_default, "DiffuseColor", "vec4");
var roughness = nodeImmutable(PropertyNode_default, "Roughness", "float");
var metalness = nodeImmutable(PropertyNode_default, "Metalness", "float");
var alphaTest = nodeImmutable(PropertyNode_default, "AlphaTest", "float");
var specularColor = nodeImmutable(PropertyNode_default, "SpecularColor", "color");
var reference = (name, nodeOrType, object) => nodeObject(new ReferenceNode_default(name, getConstNodeType(nodeOrType), object));
var materialReference = (name, nodeOrType, material) => nodeObject(new MaterialReferenceNode_default(name, getConstNodeType(nodeOrType), material));
var userData = (name, inputType, userData2) => nodeObject(new UserDataNode_default(name, inputType, userData2));
var modelViewProjection = nodeProxy(ModelViewProjectionNode_default);
var normalGeometry = nodeImmutable(NormalNode_default, NormalNode_default.GEOMETRY);
var normalLocal = nodeImmutable(NormalNode_default, NormalNode_default.LOCAL);
var normalWorld = nodeImmutable(NormalNode_default, NormalNode_default.WORLD);
var normalView = nodeImmutable(NormalNode_default, NormalNode_default.VIEW);
var transformedNormalView = nodeImmutable(VarNode_default, normalView, "TransformedNormalView");
var modelViewMatrix = nodeImmutable(ModelNode_default, ModelNode_default.VIEW_MATRIX);
var modelNormalMatrix = nodeImmutable(ModelNode_default, ModelNode_default.NORMAL_MATRIX);
var modelWorldMatrix = nodeImmutable(ModelNode_default, ModelNode_default.WORLD_MATRIX);
var modelPosition = nodeImmutable(ModelNode_default, ModelNode_default.POSITION);
var modelViewPosition = nodeImmutable(ModelNode_default, ModelNode_default.VIEW_POSITION);
var positionGeometry = nodeImmutable(PositionNode_default, PositionNode_default.GEOMETRY);
var positionLocal = nodeImmutable(PositionNode_default, PositionNode_default.LOCAL);
var positionWorld = nodeImmutable(PositionNode_default, PositionNode_default.WORLD);
var positionView = nodeImmutable(PositionNode_default, PositionNode_default.VIEW);
var positionViewDirection = nodeImmutable(PositionNode_default, PositionNode_default.VIEW_DIRECTION);
var texture = nodeProxy(TextureNode_default);
var sampler = (texture2) => nodeObject(new ConvertNode_default(texture2.isNode === true ? texture2 : new TextureNode_default(texture2), "sampler"));
var uv = (...params) => nodeObject(new UVNode_default(...params));
var pointUV = nodeImmutable(PointUVNode_default);
var compute = (node, count, workgroupSize) => nodeObject(new ComputeNode_default(nodeObject(node), count, workgroupSize));
var EPSILON = float(1e-6);
var INFINITY = float(1e6);
var cond = nodeProxy(CondNode_default);
var add = nodeProxy(OperatorNode_default, "+");
var sub = nodeProxy(OperatorNode_default, "-");
var mul = nodeProxy(OperatorNode_default, "*");
var div = nodeProxy(OperatorNode_default, "/");
var remainder = nodeProxy(OperatorNode_default, "%");
var equal = nodeProxy(OperatorNode_default, "==");
var assign = nodeProxy(OperatorNode_default, "=");
var lessThan = nodeProxy(OperatorNode_default, "<");
var greaterThan = nodeProxy(OperatorNode_default, ">");
var lessThanEqual = nodeProxy(OperatorNode_default, "<=");
var greaterThanEqual = nodeProxy(OperatorNode_default, ">=");
var and = nodeProxy(OperatorNode_default, "&&");
var or = nodeProxy(OperatorNode_default, "||");
var xor = nodeProxy(OperatorNode_default, "^^");
var bitAnd = nodeProxy(OperatorNode_default, "&");
var bitOr = nodeProxy(OperatorNode_default, "|");
var bitXor = nodeProxy(OperatorNode_default, "^");
var shiftLeft = nodeProxy(OperatorNode_default, "<<");
var shiftRight = nodeProxy(OperatorNode_default, ">>");
var radians = nodeProxy(MathNode_default, MathNode_default.RADIANS);
var degrees = nodeProxy(MathNode_default, MathNode_default.DEGREES);
var exp = nodeProxy(MathNode_default, MathNode_default.EXP);
var exp2 = nodeProxy(MathNode_default, MathNode_default.EXP2);
var log = nodeProxy(MathNode_default, MathNode_default.LOG);
var log2 = nodeProxy(MathNode_default, MathNode_default.LOG2);
var sqrt = nodeProxy(MathNode_default, MathNode_default.SQRT);
var inversesqrt = nodeProxy(MathNode_default, MathNode_default.INVERSE_SQRT);
var floor = nodeProxy(MathNode_default, MathNode_default.FLOOR);
var ceil = nodeProxy(MathNode_default, MathNode_default.CEIL);
var normalize = nodeProxy(MathNode_default, MathNode_default.NORMALIZE);
var fract = nodeProxy(MathNode_default, MathNode_default.FRACT);
var sin = nodeProxy(MathNode_default, MathNode_default.SIN);
var cos = nodeProxy(MathNode_default, MathNode_default.COS);
var tan = nodeProxy(MathNode_default, MathNode_default.TAN);
var asin = nodeProxy(MathNode_default, MathNode_default.ASIN);
var acos = nodeProxy(MathNode_default, MathNode_default.ACOS);
var atan = nodeProxy(MathNode_default, MathNode_default.ATAN);
var abs = nodeProxy(MathNode_default, MathNode_default.ABS);
var sign = nodeProxy(MathNode_default, MathNode_default.SIGN);
var length = nodeProxy(MathNode_default, MathNode_default.LENGTH);
var negate = nodeProxy(MathNode_default, MathNode_default.NEGATE);
var invert = nodeProxy(MathNode_default, MathNode_default.INVERT);
var dFdx = nodeProxy(MathNode_default, MathNode_default.DFDX);
var dFdy = nodeProxy(MathNode_default, MathNode_default.DFDY);
var saturate = nodeProxy(MathNode_default, MathNode_default.SATURATE);
var round = nodeProxy(MathNode_default, MathNode_default.ROUND);
var atan2 = nodeProxy(MathNode_default, MathNode_default.ATAN2);
var min = nodeProxy(MathNode_default, MathNode_default.MIN);
var max = nodeProxy(MathNode_default, MathNode_default.MAX);
var mod = nodeProxy(MathNode_default, MathNode_default.MOD);
var step = nodeProxy(MathNode_default, MathNode_default.STEP);
var reflect = nodeProxy(MathNode_default, MathNode_default.REFLECT);
var distance = nodeProxy(MathNode_default, MathNode_default.DISTANCE);
var dot = nodeProxy(MathNode_default, MathNode_default.DOT);
var cross = nodeProxy(MathNode_default, MathNode_default.CROSS);
var pow = nodeProxy(MathNode_default, MathNode_default.POW);
var pow2 = nodeProxy(MathNode_default, MathNode_default.POW, 2);
var pow3 = nodeProxy(MathNode_default, MathNode_default.POW, 3);
var pow4 = nodeProxy(MathNode_default, MathNode_default.POW, 4);
var transformDirection = nodeProxy(MathNode_default, MathNode_default.TRANSFORM_DIRECTION);
var mix = nodeProxy(MathNode_default, MathNode_default.MIX);
var clamp = nodeProxy(MathNode_default, MathNode_default.CLAMP);
var refract = nodeProxy(MathNode_default, MathNode_default.REFRACT);
var smoothstep = nodeProxy(MathNode_default, MathNode_default.SMOOTHSTEP);
var faceforward = nodeProxy(MathNode_default, MathNode_default.FACEFORWARD);
var frontFacing = nodeImmutable(FrontFacingNode_default);
var faceDirection = sub(mul(float(frontFacing), 2), 1);
var element = nodeProxy(ArrayElementNode_default);
var dotNV = saturate(dot(transformedNormalView, positionViewDirection));
var transformedNormalWorld = normalize(transformDirection(transformedNormalView, cameraViewMatrix));

// node_modules/three/examples/jsm/nodes/accessors/ReflectVectorNode.js
var ReflectVectorNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  getHash() {
    return `reflectVector`;
  }
  construct() {
    const reflectView = reflect(negate(positionViewDirection), transformedNormalView);
    return transformDirection(reflectView, cameraViewMatrix);
  }
};
var ReflectVectorNode_default = ReflectVectorNode;

// node_modules/three/examples/jsm/nodes/accessors/CubeTextureNode.js
var CubeTextureNode = class extends TextureNode_default {
  constructor(value, uvNode = null, levelNode = null) {
    super(value, uvNode, levelNode);
    this.isCubeTextureNode = true;
  }
  getInputType() {
    return "cubeTexture";
  }
  getConstructHash(builder) {
    var _a;
    return `${this.uuid} / ${((_a = builder.context.environmentContext) == null ? void 0 : _a.uuid) || ""}`;
  }
  construct(builder) {
    const properties = builder.getNodeProperties(this);
    const uvNode = this.uvNode || builder.context.uvNode || new ReflectVectorNode_default();
    let levelNode = this.levelNode || builder.context.levelNode;
    if ((levelNode == null ? void 0 : levelNode.isNode) === true) {
      const texture2 = this.value;
      levelNode = builder.context.levelShaderNode ? builder.context.levelShaderNode.call({ texture: texture2, levelNode }, builder) : levelNode;
    }
    properties.uvNode = uvNode;
    properties.levelNode = levelNode;
  }
  generate(builder, output) {
    const { uvNode, levelNode } = builder.getNodeProperties(this);
    const texture2 = this.value;
    if (!texture2 || texture2.isCubeTexture !== true) {
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    }
    const textureProperty = UniformNode_default.prototype.generate.call(this, builder, "cubeTexture");
    if (output === "sampler") {
      return textureProperty + "_sampler";
    } else if (builder.isReference(output)) {
      return textureProperty;
    } else {
      const nodeData = builder.getDataFromNode(this);
      let snippet = nodeData.snippet;
      if (snippet === void 0 || builder.context.tempRead === false) {
        const uvNodeObject = nodeObject(uvNode);
        const cubeUV = vec3(negate(uvNodeObject.x), uvNodeObject.yz);
        const uvSnippet = cubeUV.build(builder, "vec3");
        if (levelNode) {
          const levelSnippet = levelNode.build(builder, "float");
          snippet = builder.getCubeTextureLevel(textureProperty, uvSnippet, levelSnippet);
        } else {
          snippet = builder.getCubeTexture(textureProperty, uvSnippet);
        }
        nodeData.snippet = snippet;
      }
      return builder.format(snippet, "vec4", output);
    }
  }
};
var CubeTextureNode_default = CubeTextureNode;

// node_modules/three/examples/jsm/nodes/accessors/InstanceNode.js
var InstanceNode = class extends Node_default {
  constructor(instanceMesh) {
    super("void");
    this.instanceMesh = instanceMesh;
    const instanceBufferNode = buffer(instanceMesh.instanceMatrix.array, "mat4", instanceMesh.count);
    this.instanceMatrixNode = temp(element(instanceBufferNode, instanceIndex));
  }
  generate(builder) {
    const { instanceMatrixNode } = this;
    const instancePosition = mul(instanceMatrixNode, positionLocal).xyz;
    const m = mat3(instanceMatrixNode[0].xyz, instanceMatrixNode[1].xyz, instanceMatrixNode[2].xyz);
    const transformedNormal = div(normalLocal, vec3(dot(m[0], m[0]), dot(m[1], m[1]), dot(m[2], m[2])));
    const instanceNormal = mul(m, transformedNormal).xyz;
    assign(positionLocal, instancePosition).build(builder);
    assign(normalLocal, instanceNormal).build(builder);
  }
};
var InstanceNode_default = InstanceNode;

// node_modules/three/examples/jsm/nodes/accessors/SkinningNode.js
var Skinning = new ShaderNode((inputs, builder) => {
  const { index, weight, bindMatrix, bindMatrixInverse, boneMatrices } = inputs;
  const boneMatX = element(boneMatrices, index.x);
  const boneMatY = element(boneMatrices, index.y);
  const boneMatZ = element(boneMatrices, index.z);
  const boneMatW = element(boneMatrices, index.w);
  const skinVertex = mul(bindMatrix, positionLocal);
  const skinned = add(
    mul(mul(boneMatX, skinVertex), weight.x),
    mul(mul(boneMatY, skinVertex), weight.y),
    mul(mul(boneMatZ, skinVertex), weight.z),
    mul(mul(boneMatW, skinVertex), weight.w)
  );
  const skinPosition = mul(bindMatrixInverse, skinned).xyz;
  let skinMatrix = add(
    mul(weight.x, boneMatX),
    mul(weight.y, boneMatY),
    mul(weight.z, boneMatZ),
    mul(weight.w, boneMatW)
  );
  skinMatrix = mul(mul(bindMatrixInverse, skinMatrix), bindMatrix);
  const skinNormal = transformDirection(skinMatrix, normalLocal).xyz;
  assign(positionLocal, skinPosition).build(builder);
  assign(normalLocal, skinNormal).build(builder);
});
var SkinningNode = class extends Node_default {
  constructor(skinnedMesh) {
    super("void");
    this.skinnedMesh = skinnedMesh;
    this.updateType = NodeUpdateType.Object;
    this.skinIndexNode = attribute("skinIndex", "uvec4");
    this.skinWeightNode = attribute("skinWeight", "vec4");
    this.bindMatrixNode = uniform(mat4(skinnedMesh.bindMatrix));
    this.bindMatrixInverseNode = uniform(mat4(skinnedMesh.bindMatrixInverse));
    this.boneMatricesNode = buffer(skinnedMesh.skeleton.boneMatrices, "mat4", skinnedMesh.skeleton.bones.length);
  }
  generate(builder) {
    Skinning.call({
      index: this.skinIndexNode,
      weight: this.skinWeightNode,
      bindMatrix: this.bindMatrixNode,
      bindMatrixInverse: this.bindMatrixInverseNode,
      boneMatrices: this.boneMatricesNode
    }, builder);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
};
var SkinningNode_default = SkinningNode;

// node_modules/three/examples/jsm/nodes/geometry/RangeNode.js
var RangeNode = class extends Node_default {
  constructor(min2, max2) {
    super();
    this.min = min2;
    this.max = max2;
  }
  getVectorLength() {
    const min2 = this.min;
    let length2 = 1;
    if (min2.isVector2)
      length2 = 2;
    else if (min2.isVector3)
      length2 = 3;
    else if (min2.isVector4)
      length2 = 4;
    else if (min2.isColor)
      length2 = 3;
    return length2;
  }
  getNodeType(builder) {
    return builder.object.isInstancedMesh === true ? builder.getTypeFromLength(this.getVectorLength()) : "float";
  }
  construct(builder) {
    const { min: min2, max: max2 } = this;
    const { object, geometry } = builder;
    let output = null;
    if (object.isInstancedMesh === true) {
      const vectorLength = this.getVectorLength();
      const attributeName = "node" + this.id;
      const length2 = vectorLength * object.count;
      const array = new Float32Array(length2);
      const attributeGeometry = geometry.getAttribute(attributeName);
      if (attributeGeometry === void 0 || attributeGeometry.array.length < length2) {
        if (vectorLength === 1) {
          for (let i = 0; i < length2; i++) {
            array[i] = MathUtils.lerp(min2, max2, Math.random());
          }
        } else if (min2.isColor) {
          for (let i = 0; i < length2; i += 3) {
            array[i] = MathUtils.lerp(min2.r, max2.r, Math.random());
            array[i + 1] = MathUtils.lerp(min2.g, max2.g, Math.random());
            array[i + 2] = MathUtils.lerp(min2.b, max2.b, Math.random());
          }
        } else {
          for (let i = 0; i < length2; i++) {
            const index = i % vectorLength;
            const minValue = min2.getComponent(index);
            const maxValue = max2.getComponent(index);
            array[i] = MathUtils.lerp(minValue, maxValue, Math.random());
          }
        }
        geometry.setAttribute(attributeName, new InstancedBufferAttribute(array, vectorLength));
        geometry.dispose();
      }
      output = attribute(attributeName, builder.getTypeFromLength(vectorLength));
    } else {
      output = float(0);
    }
    return output;
  }
};
var RangeNode_default = RangeNode;

// node_modules/three/examples/jsm/nodes/display/ColorAdjustmentNode.js
var luminanceNode = new ShaderNode(({ color: color2 }) => {
  const LUMA = vec3(0.2125, 0.7154, 0.0721);
  return dot(color2, LUMA);
});
var saturationNode = new ShaderNode(({ color: color2, adjustment }) => {
  const intensityNode = luminanceNode.call({ color: color2 });
  return mix(intensityNode, color2, adjustment);
});
var vibranceNode = new ShaderNode(({ color: color2, adjustment }) => {
  const average = div(add(color2.r, color2.g, color2.b), 3);
  const mx = max(color2.r, max(color2.g, color2.b));
  const amt = mul(sub(mx, average), mul(-3, adjustment));
  return mix(color2.rgb, vec3(mx), amt);
});
var hueNode = new ShaderNode(({ color: color2, adjustment }) => {
  const RGBtoYIQ = mat3(0.299, 0.587, 0.114, 0.595716, -0.274453, -0.321263, 0.211456, -0.522591, 0.311135);
  const YIQtoRGB = mat3(1, 0.9563, 0.621, 1, -0.2721, -0.6474, 1, -1.107, 1.7046);
  const yiq = mul(RGBtoYIQ, color2);
  const hue2 = add(atan2(yiq.z, yiq.y), adjustment);
  const chroma = sqrt(add(mul(yiq.z, yiq.z), mul(yiq.y, yiq.y)));
  return mul(YIQtoRGB, vec3(yiq.x, mul(chroma, cos(hue2)), mul(chroma, sin(hue2))));
});
var _ColorAdjustmentNode = class _ColorAdjustmentNode extends TempNode_default {
  constructor(method, colorNode, adjustmentNode = float(1)) {
    super("vec3");
    this.method = method;
    this.colorNode = colorNode;
    this.adjustmentNode = adjustmentNode;
  }
  construct() {
    const { method, colorNode, adjustmentNode } = this;
    const callParams = { color: colorNode, adjustment: adjustmentNode };
    let outputNode = null;
    if (method === _ColorAdjustmentNode.SATURATION) {
      outputNode = saturationNode.call(callParams);
    } else if (method === _ColorAdjustmentNode.VIBRANCE) {
      outputNode = vibranceNode.call(callParams);
    } else if (method === _ColorAdjustmentNode.HUE) {
      outputNode = hueNode.call(callParams);
    } else {
      console.error(`${this.type}: Method "${this.method}" not supported!`);
    }
    return outputNode;
  }
};
__publicField(_ColorAdjustmentNode, "SATURATION", "saturation");
__publicField(_ColorAdjustmentNode, "VIBRANCE", "vibrance");
__publicField(_ColorAdjustmentNode, "HUE", "hue");
var ColorAdjustmentNode = _ColorAdjustmentNode;
var ColorAdjustmentNode_default = ColorAdjustmentNode;

// node_modules/three/examples/jsm/nodes/display/ColorSpaceNode.js
var LinearToLinear = new ShaderNode((inputs) => {
  return inputs.value;
});
var LinearTosRGB = new ShaderNode((inputs) => {
  const { value } = inputs;
  const rgb = value.rgb;
  const a = sub(mul(pow(value.rgb, vec3(0.41666)), 1.055), vec3(0.055));
  const b = mul(rgb, 12.92);
  const factor = vec3(lessThanEqual(rgb, vec3(31308e-7)));
  const rgbResult = mix(a, b, factor);
  return vec4(rgbResult, value.a);
});
var EncodingLib = {
  LinearToLinear,
  LinearTosRGB
};
var _ColorSpaceNode = class _ColorSpaceNode extends Node_default {
  constructor(method, node) {
    super("vec4");
    this.method = method;
    this.node = node;
  }
  fromEncoding(encoding) {
    let method = null;
    if (encoding === LinearEncoding) {
      method = "Linear";
    } else if (encoding === sRGBEncoding) {
      method = "sRGB";
    }
    this.method = "LinearTo" + method;
    return this;
  }
  construct() {
    const method = this.method;
    const node = this.node;
    let outputNode = null;
    if (method !== _ColorSpaceNode.LINEAR_TO_LINEAR) {
      const encodingFunctionNode = EncodingLib[method];
      outputNode = encodingFunctionNode.call({
        value: node
      });
    } else {
      outputNode = node;
    }
    return outputNode;
  }
};
__publicField(_ColorSpaceNode, "LINEAR_TO_LINEAR", "LinearToLinear");
__publicField(_ColorSpaceNode, "LINEAR_TO_SRGB", "LinearTosRGB");
var ColorSpaceNode = _ColorSpaceNode;
var ColorSpaceNode_default = ColorSpaceNode;

// node_modules/three/examples/jsm/nodes/display/NormalMapNode.js
var perturbNormal2ArbNode = new ShaderNode((inputs) => {
  const { eye_pos, surf_norm, mapN, uv: uv2 } = inputs;
  const q0 = dFdx(eye_pos.xyz);
  const q1 = dFdy(eye_pos.xyz);
  const st0 = dFdx(uv2.st);
  const st1 = dFdy(uv2.st);
  const N = surf_norm;
  const q1perp = cross(q1, N);
  const q0perp = cross(N, q0);
  const T = add(mul(q1perp, st0.x), mul(q0perp, st1.x));
  const B = add(mul(q1perp, st0.y), mul(q0perp, st1.y));
  const det = max(dot(T, T), dot(B, B));
  const scale = mul(faceDirection, inversesqrt(det));
  return normalize(add(mul(T, mul(mapN.x, scale)), mul(B, mul(mapN.y, scale)), mul(N, mapN.z)));
});
var NormalMapNode = class extends TempNode_default {
  constructor(node, scaleNode = null) {
    super("vec3");
    this.node = node;
    this.scaleNode = scaleNode;
    this.normalMapType = TangentSpaceNormalMap;
  }
  construct() {
    const { normalMapType, scaleNode } = this;
    const normalOP = mul(this.node, 2);
    let normalMap2 = sub(normalOP, 1);
    if (scaleNode !== null) {
      const normalMapScale = mul(normalMap2.xy, scaleNode);
      normalMap2 = vec3(normalMapScale, normalMap2.z);
    }
    let outputNode = null;
    if (normalMapType === ObjectSpaceNormalMap) {
      const vertexNormalNode = mul(new ModelNode_default(ModelNode_default.NORMAL_MATRIX), normalMap2);
      outputNode = normalize(vertexNormalNode);
    } else if (normalMapType === TangentSpaceNormalMap) {
      outputNode = perturbNormal2ArbNode.call({
        eye_pos: positionView,
        surf_norm: normalView,
        mapN: normalMap2,
        uv: uv()
      });
    }
    return outputNode;
  }
};
var NormalMapNode_default = NormalMapNode;

// node_modules/three/examples/jsm/nodes/display/ToneMappingNode.js
var LinearToneMappingNode = new ShaderNode(({ color: color2, exposure }) => {
  return mul(color2, exposure);
});
var ToneMappingNode = class extends Node_default {
  constructor(toneMapping2, exposureNode = float(1), colorNode = null) {
    super("vec3");
    this.toneMapping = toneMapping2;
    this.exposureNode = exposureNode;
    this.colorNode = colorNode;
  }
  construct(builder) {
    const colorNode = this.color || builder.context.color;
    const toneMapping2 = this.toneMapping;
    const toneMappingParams = { exposure: this.exposureNode, color: colorNode };
    let outputNode = null;
    if (toneMapping2 === LinearToneMapping) {
      outputNode = LinearToneMappingNode.call(toneMappingParams);
    } else {
      outputNode = this.colorNode;
    }
    return outputNode;
  }
};
var ToneMappingNode_default = ToneMappingNode;

// node_modules/three/examples/jsm/nodes/lighting/LightingNode.js
var LightingNode = class extends Node_default {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
};
var LightingNode_default = LightingNode;

// node_modules/three/examples/jsm/nodes/lighting/LightsNode.js
var references = /* @__PURE__ */ new WeakMap();
var sortLights = (lights2) => {
  return lights2.sort((a, b) => a.id - b.id);
};
var LightsNode = class extends Node_default {
  constructor(lightNodes = []) {
    super("vec3");
    this.lightNodes = lightNodes;
    this._hash = null;
  }
  get hasLight() {
    return this.lightNodes.length > 0;
  }
  construct(builder) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      lightNode.build(builder);
    }
  }
  getHash(builder) {
    if (this._hash === null) {
      let hash = "";
      const lightNodes = this.lightNodes;
      for (const lightNode of lightNodes) {
        hash += lightNode.getHash(builder) + " ";
      }
      this._hash = hash;
    }
    return this._hash;
  }
  getLightNodeByHash(hash) {
    const lightNodes = this.lightNodes;
    for (const lightNode of lightNodes) {
      if (lightNode.light.uuid === hash) {
        return lightNode;
      }
    }
    return null;
  }
  fromLights(lights2) {
    const lightNodes = [];
    lights2 = sortLights(lights2);
    for (const light of lights2) {
      let lightNode = this.getLightNodeByHash(light.uuid);
      if (lightNode === null) {
        const lightClass = light.constructor;
        const lightNodeClass = references.has(lightClass) ? references.get(lightClass) : LightingNode_default;
        lightNode = new lightNodeClass(light);
      }
      lightNodes.push(lightNode);
    }
    this.lightNodes = lightNodes;
    this._hash = null;
    return this;
  }
  static setReference(lightClass, lightNodeClass) {
    references.set(lightClass, lightNodeClass);
  }
};
var LightsNode_default = LightsNode;

// node_modules/three/examples/jsm/nodes/lighting/LightingContextNode.js
var LightingContextNode = class extends ContextNode_default {
  constructor(node, lightingModelNode = null) {
    super(node);
    this.lightingModelNode = lightingModelNode;
  }
  getNodeType() {
    return "vec3";
  }
  construct(builder) {
    const { lightingModelNode } = this;
    const context2 = this.context = {};
    const properties = builder.getNodeProperties(this);
    const directDiffuse = temp(vec3()), directSpecular = temp(vec3()), indirectDiffuse = temp(vec3()), indirectSpecular = temp(vec3()), total = add(directDiffuse, directSpecular, indirectDiffuse, indirectSpecular);
    const reflectedLight = {
      directDiffuse,
      directSpecular,
      indirectDiffuse,
      indirectSpecular,
      total
    };
    const lighting = {
      radiance: temp(vec3()),
      irradiance: temp(vec3()),
      iblIrradiance: temp(vec3()),
      ambientOcclusion: temp(float(1))
    };
    Object.assign(properties, reflectedLight, lighting);
    Object.assign(context2, lighting);
    context2.reflectedLight = reflectedLight;
    context2.lightingModelNode = lightingModelNode || context2.lightingModelNode;
    if (lightingModelNode == null ? void 0 : lightingModelNode.indirectDiffuse)
      lightingModelNode.indirectDiffuse.call(context2);
    if (lightingModelNode == null ? void 0 : lightingModelNode.indirectSpecular)
      lightingModelNode.indirectSpecular.call(context2);
    if (lightingModelNode == null ? void 0 : lightingModelNode.ambientOcclusion)
      lightingModelNode.ambientOcclusion.call(context2);
    return super.construct(builder);
  }
  generate(builder) {
    const { context: context2 } = this;
    const type = this.getNodeType(builder);
    super.generate(builder, type);
    return context2.reflectedLight.total.build(builder, type);
  }
};
var LightingContextNode_default = LightingContextNode;

// node_modules/three/examples/jsm/nodes/utils/MatcapUVNode.js
var MatcapUVNode = class extends TempNode_default {
  constructor() {
    super("vec2");
  }
  generate(builder) {
    const x = normalize(vec3(positionViewDirection.z, 0, negate(positionViewDirection.x)));
    const y = cross(positionViewDirection, x);
    const uv2 = add(mul(vec2(dot(x, transformedNormalView), dot(y, transformedNormalView)), 0.495), 0.5);
    return uv2.build(builder, this.getNodeType(builder));
  }
};
var MatcapUVNode_default = MatcapUVNode;

// node_modules/three/examples/jsm/nodes/utils/MaxMipLevelNode.js
var MaxMipLevelNode = class extends UniformNode_default {
  constructor(texture2) {
    super(0);
    this.texture = texture2;
    this.updateType = NodeUpdateType.Frame;
  }
  update() {
    var _a;
    const images = this.texture.images;
    const image = images && images.length > 0 ? ((_a = images[0]) == null ? void 0 : _a.image) || images[0] : this.texture.image;
    if ((image == null ? void 0 : image.width) !== void 0) {
      const { width, height } = image;
      this.value = Math.log2(Math.max(width, height));
    }
  }
};
var MaxMipLevelNode_default = MaxMipLevelNode;

// node_modules/three/examples/jsm/nodes/utils/TimerNode.js
var _TimerNode = class _TimerNode extends UniformNode_default {
  constructor(scope = _TimerNode.LOCAL, scale = 1, value = 0) {
    super(value);
    this.scope = scope;
    this.scale = scale;
    this.updateType = NodeUpdateType.Frame;
  }
  update(frame) {
    const scope = this.scope;
    const scale = this.scale;
    if (scope === _TimerNode.LOCAL) {
      this.value += frame.deltaTime * scale;
    } else if (scope === _TimerNode.DELTA) {
      this.value = frame.deltaTime * scale;
    } else {
      this.value = frame.time * scale;
    }
  }
  serialize(data) {
    super.serialize(data);
    data.scope = this.scope;
    data.scale = this.scale;
  }
  deserialize(data) {
    super.deserialize(data);
    this.scope = data.scope;
    this.scale = data.scale;
  }
};
__publicField(_TimerNode, "LOCAL", "local");
__publicField(_TimerNode, "GLOBAL", "global");
__publicField(_TimerNode, "DELTA", "delta");
var TimerNode = _TimerNode;
var TimerNode_default = TimerNode;

// node_modules/three/examples/jsm/nodes/utils/OscNode.js
var _OscNode = class _OscNode extends Node_default {
  constructor(method = _OscNode.SINE, timeNode = new TimerNode_default()) {
    super();
    this.method = method;
    this.timeNode = timeNode;
  }
  getNodeType(builder) {
    return this.timeNode.getNodeType(builder);
  }
  generate(builder) {
    const method = this.method;
    const timeNode = this.timeNode;
    let outputNode = null;
    if (method === _OscNode.SINE) {
      outputNode = add(mul(sin(mul(add(timeNode, 0.75), Math.PI * 2)), 0.5), 0.5);
    } else if (method === _OscNode.SQUARE) {
      outputNode = round(fract(timeNode));
    } else if (method === _OscNode.TRIANGLE) {
      outputNode = abs(sub(1, mul(fract(add(timeNode, 0.5)), 2)));
    } else if (method === _OscNode.SAWTOOTH) {
      outputNode = fract(timeNode);
    }
    return outputNode.build(builder);
  }
  serialize(data) {
    super.serialize(data);
    data.method = this.method;
  }
  deserialize(data) {
    super.deserialize(data);
    this.method = data.method;
  }
};
__publicField(_OscNode, "SINE", "sine");
__publicField(_OscNode, "SQUARE", "square");
__publicField(_OscNode, "TRIANGLE", "triangle");
__publicField(_OscNode, "SAWTOOTH", "sawtooth");
var OscNode = _OscNode;
var OscNode_default = OscNode;

// node_modules/three/examples/jsm/nodes/utils/RotateUVNode.js
var RotateUVNode = class extends TempNode_default {
  constructor(uvNode, rotationNode, centerNode = vec2(0.5)) {
    super("vec2");
    this.uvNode = uvNode;
    this.rotationNode = rotationNode;
    this.centerNode = centerNode;
  }
  construct() {
    const { uvNode, rotationNode, centerNode } = this;
    const cosAngle = cos(rotationNode);
    const sinAngle = sin(rotationNode);
    return vec2(
      add(add(mul(cosAngle, sub(uvNode.x, centerNode.x)), mul(sinAngle, sub(uvNode.y, centerNode.y))), centerNode.x),
      add(sub(mul(cosAngle, sub(uvNode.y, centerNode.y)), mul(sinAngle, sub(uvNode.x, centerNode.x))), centerNode.y)
    );
  }
};
var RotateUVNode_default = RotateUVNode;

// node_modules/three/examples/jsm/nodes/utils/SpriteSheetUVNode.js
var SpriteSheetUVNode = class extends Node_default {
  constructor(countNode, uvNode = new UVNode_default(), frameNode = new ConstNode_default(0)) {
    super("vec2");
    this.countNode = countNode;
    this.uvNode = uvNode;
    this.frameNode = frameNode;
  }
  generate(builder) {
    const count = this.countNode;
    const uv2 = this.uvNode;
    const frame = this.frameNode;
    const one = new ConstNode_default(1);
    const width = new SplitNode_default(count, "x");
    const height = new SplitNode_default(count, "y");
    const total = new OperatorNode_default("*", width, height);
    const roundFrame = new MathNode_default(MathNode_default.FLOOR, new MathNode_default(MathNode_default.MOD, frame, total));
    const frameNum = new OperatorNode_default("+", roundFrame, one);
    const cell = new MathNode_default(MathNode_default.MOD, roundFrame, width);
    const row = new MathNode_default(MathNode_default.CEIL, new OperatorNode_default("/", frameNum, width));
    const rowInv = new OperatorNode_default("-", height, row);
    const scale = new OperatorNode_default("/", one, count);
    const uvFrameOffset = new JoinNode_default([
      new OperatorNode_default("*", cell, new SplitNode_default(scale, "x")),
      new OperatorNode_default("*", rowInv, new SplitNode_default(scale, "y"))
    ]);
    const uvScale = new OperatorNode_default("*", uv2, scale);
    const uvFrame = new OperatorNode_default("+", uvScale, uvFrameOffset);
    return uvFrame.build(builder, this.getNodeType(builder));
  }
};
var SpriteSheetUVNode_default = SpriteSheetUVNode;

// node_modules/three/examples/jsm/nodes/procedural/CheckerNode.js
var checkerShaderNode = new ShaderNode((inputs) => {
  const uv2 = mul(inputs.uv, 2);
  const cx = floor(uv2.x);
  const cy = floor(uv2.y);
  const result = mod(add(cx, cy), 2);
  return sign(result);
});
var CheckerNode = class extends Node_default {
  constructor(uvNode = uv()) {
    super("float");
    this.uvNode = uvNode;
  }
  generate(builder) {
    return checkerShaderNode.call({ uv: this.uvNode }).build(builder);
  }
};
var CheckerNode_default = CheckerNode;

// node_modules/three/examples/jsm/nodes/fog/FogNode.js
var FogNode = class extends Node_default {
  constructor(colorNode, factorNode) {
    super("float");
    this.isFogNode = true;
    this.colorNode = colorNode;
    this.factorNode = factorNode;
  }
  mix(outputNode) {
    return new MathNode_default(MathNode_default.MIX, outputNode, this.colorNode, this);
  }
  generate(builder) {
    return this.factorNode.build(builder, "float");
  }
};
var FogNode_default = FogNode;

// node_modules/three/examples/jsm/nodes/fog/FogRangeNode.js
var FogRangeNode = class extends FogNode_default {
  constructor(colorNode, nearNode, farNode) {
    super(colorNode);
    this.isFogRangeNode = true;
    this.nearNode = nearNode;
    this.farNode = farNode;
  }
  generate(builder) {
    this.factorNode = smoothstep(this.nearNode, this.farNode, negate(positionView.z));
    return super.generate(builder);
  }
};
var FogRangeNode_default = FogRangeNode;

// node_modules/three/examples/jsm/nodes/functions/BSDF/F_Schlick.js
var F_Schlick = new ShaderNode((inputs) => {
  const { f0, f90, dotVH } = inputs;
  const fresnel = exp2(mul(sub(mul(-5.55473, dotVH), 6.98316), dotVH));
  return add(mul(f0, sub(1, fresnel)), mul(f90, fresnel));
});
var F_Schlick_default = F_Schlick;

// node_modules/three/examples/jsm/nodes/functions/BSDF/V_GGX_SmithCorrelated.js
var V_GGX_SmithCorrelated = new ShaderNode((inputs) => {
  const { alpha, dotNL, dotNV: dotNV2 } = inputs;
  const a2 = pow2(alpha);
  const gv = mul(dotNL, sqrt(add(a2, mul(sub(1, a2), pow2(dotNV2)))));
  const gl = mul(dotNV2, sqrt(add(a2, mul(sub(1, a2), pow2(dotNL)))));
  return div(0.5, max(add(gv, gl), EPSILON));
});
var V_GGX_SmithCorrelated_default = V_GGX_SmithCorrelated;

// node_modules/three/examples/jsm/nodes/functions/BSDF/D_GGX.js
var D_GGX = new ShaderNode((inputs) => {
  const { alpha, dotNH } = inputs;
  const a2 = pow2(alpha);
  const denom = add(mul(pow2(dotNH), sub(a2, 1)), 1);
  return mul(1 / Math.PI, div(a2, pow2(denom)));
});
var D_GGX_default = D_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_GGX.js
var BRDF_GGX = new ShaderNode((inputs) => {
  const { lightDirection, f0, f90, roughness: roughness2 } = inputs;
  const alpha = pow2(roughness2);
  const halfDir = normalize(add(lightDirection, positionViewDirection));
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  const dotNH = saturate(dot(transformedNormalView, halfDir));
  const dotVH = saturate(dot(positionViewDirection, halfDir));
  const F = F_Schlick_default.call({ f0, f90, dotVH });
  const V = V_GGX_SmithCorrelated_default.call({ alpha, dotNL, dotNV });
  const D = D_GGX_default.call({ alpha, dotNH });
  return mul(F, mul(V, D));
});
var BRDF_GGX_default = BRDF_GGX;

// node_modules/three/examples/jsm/nodes/functions/BSDF/BRDF_Lambert.js
var BRDF_Lambert = new ShaderNode((inputs) => {
  return mul(1 / Math.PI, inputs.diffuseColor);
});
var BRDF_Lambert_default = BRDF_Lambert;

// node_modules/three/examples/jsm/nodes/functions/BSDF/DFGApprox.js
var DFGApprox = new ShaderNode((inputs) => {
  const { roughness: roughness2 } = inputs;
  const c0 = vec4(-1, -0.0275, -0.572, 0.022);
  const c1 = vec4(1, 0.0425, 1.04, -0.04);
  const r = add(mul(roughness2, c0), c1);
  const a004 = add(mul(min(mul(r.x, r.x), exp2(mul(-9.28, dotNV))), r.x), r.y);
  const fab = add(mul(vec2(-1.04, 1.04), a004), r.zw);
  return fab;
});
var DFGApprox_default = DFGApprox;

// node_modules/three/examples/jsm/nodes/functions/light/getDistanceAttenuation.js
var getDistanceAttenuation = new ShaderNode((inputs) => {
  const { lightDistance, cutoffDistance, decayExponent } = inputs;
  const distanceFalloff = div(1, max(pow(lightDistance, decayExponent), 0.01));
  return cond(
    greaterThan(cutoffDistance, 0),
    mul(distanceFalloff, pow2(saturate(sub(1, pow4(div(lightDistance, cutoffDistance)))))),
    distanceFalloff
  );
});
var getDistanceAttenuation_default = getDistanceAttenuation;

// node_modules/three/examples/jsm/nodes/functions/material/getGeometryRoughness.js
var getGeometryRoughness = new ShaderNode(() => {
  const dxy = max(abs(dFdx(normalGeometry)), abs(dFdy(normalGeometry)));
  const geometryRoughness = max(max(dxy.x, dxy.y), dxy.z);
  return geometryRoughness;
});
var getGeometryRoughness_default = getGeometryRoughness;

// node_modules/three/examples/jsm/nodes/functions/material/getRoughness.js
var getRoughness = new ShaderNode((inputs) => {
  const { roughness: roughness2 } = inputs;
  const geometryRoughness = getGeometryRoughness_default.call();
  let roughnessFactor = max(roughness2, 0.0525);
  roughnessFactor = add(roughnessFactor, geometryRoughness);
  roughnessFactor = min(roughnessFactor, 1);
  return roughnessFactor;
});
var getRoughness_default = getRoughness;

// node_modules/three/examples/jsm/nodes/functions/PhysicalLightingModel.js
var computeMultiscattering = (singleScatter, multiScatter, specularF90 = 1) => {
  const fab = DFGApprox_default.call({ roughness });
  const FssEss = add(mul(specularColor, fab.x), mul(specularF90, fab.y));
  const Ess = add(fab.x, fab.y);
  const Ems = sub(1, Ess);
  const Favg = add(specularColor, mul(sub(1, specularColor), 0.047619));
  const Fms = div(mul(FssEss, Favg), sub(1, mul(Ems, Favg)));
  singleScatter.add(FssEss);
  multiScatter.add(mul(Fms, Ems));
};
var RE_IndirectSpecular_Physical = new ShaderNode((inputs) => {
  const { radiance, iblIrradiance, reflectedLight } = inputs;
  const singleScattering = temp(vec3());
  const multiScattering = temp(vec3());
  const cosineWeightedIrradiance = mul(iblIrradiance, 1 / Math.PI);
  computeMultiscattering(singleScattering, multiScattering);
  const diffuse = mul(diffuseColor, sub(1, add(singleScattering, multiScattering)));
  reflectedLight.indirectSpecular.add(mul(radiance, singleScattering));
  reflectedLight.indirectSpecular.add(mul(multiScattering, cosineWeightedIrradiance));
  reflectedLight.indirectDiffuse.add(mul(diffuse, cosineWeightedIrradiance));
});
var RE_IndirectDiffuse_Physical = new ShaderNode((inputs) => {
  const { irradiance, reflectedLight } = inputs;
  reflectedLight.indirectDiffuse.add(mul(irradiance, BRDF_Lambert_default.call({ diffuseColor })));
});
var RE_Direct_Physical = new ShaderNode((inputs) => {
  const { lightDirection, lightColor, reflectedLight } = inputs;
  const dotNL = saturate(dot(transformedNormalView, lightDirection));
  const irradiance = mul(dotNL, lightColor);
  reflectedLight.directDiffuse.add(mul(irradiance, BRDF_Lambert_default.call({ diffuseColor: diffuseColor.rgb })));
  reflectedLight.directSpecular.add(mul(irradiance, BRDF_GGX_default.call({ lightDirection, f0: specularColor, f90: 1, roughness })));
});
var RE_AmbientOcclusion_Physical = new ShaderNode(({ ambientOcclusion, reflectedLight }) => {
  const aoNV = add(dotNV, ambientOcclusion);
  const aoExp = exp2(sub(mul(-16, roughness), 1));
  const aoNode = saturate(add(sub(pow(aoNV, aoExp), 1), ambientOcclusion));
  reflectedLight.indirectDiffuse.mul(ambientOcclusion);
  reflectedLight.indirectSpecular.mul(aoNode);
});
var PhysicalLightingModel = {
  direct: RE_Direct_Physical,
  indirectDiffuse: RE_IndirectDiffuse_Physical,
  indirectSpecular: RE_IndirectSpecular_Physical,
  ambientOcclusion: RE_AmbientOcclusion_Physical
};
var PhysicalLightingModel_default = PhysicalLightingModel;

// node_modules/three/examples/jsm/nodes/shadernode/ShaderNodeElements.js
var cubeTexture = nodeProxy(CubeTextureNode_default);
var instance = nodeProxy(InstanceNode_default);
var reflectVector = nodeImmutable(ReflectVectorNode_default);
var skinning = nodeProxy(SkinningNode_default);
var saturation = nodeProxy(ColorAdjustmentNode_default, ColorAdjustmentNode_default.SATURATION);
var vibrance = nodeProxy(ColorAdjustmentNode_default, ColorAdjustmentNode_default.VIBRANCE);
var hue = nodeProxy(ColorAdjustmentNode_default, ColorAdjustmentNode_default.HUE);
var colorSpace = (node, encoding) => nodeObject(new ColorSpaceNode_default(null, nodeObject(node)).fromEncoding(encoding));
var normalMap = nodeProxy(NormalMapNode_default);
var toneMapping = (mapping, exposure, color2) => nodeObject(new ToneMappingNode_default(mapping, nodeObject(exposure), nodeObject(color2)));
var lights = (lights2) => nodeObject(new LightsNode_default().fromLights(lights2));
var lightingContext = nodeProxy(LightingContextNode_default);
var matcapUV = nodeImmutable(MatcapUVNode_default);
var maxMipLevel = nodeProxy(MaxMipLevelNode_default);
var oscSine = nodeProxy(OscNode_default, OscNode_default.SINE);
var oscSquare = nodeProxy(OscNode_default, OscNode_default.SQUARE);
var oscTriangle = nodeProxy(OscNode_default, OscNode_default.TRIANGLE);
var oscSawtooth = nodeProxy(OscNode_default, OscNode_default.SAWTOOTH);
var rotateUV = nodeProxy(RotateUVNode_default);
var spritesheetUV = nodeProxy(SpriteSheetUVNode_default);
var timerLocal = (timeScale, value = 0) => nodeObject(new TimerNode_default(TimerNode_default.LOCAL, timeScale, value));
var timerGlobal = (timeScale, value = 0) => nodeObject(new TimerNode_default(TimerNode_default.GLOBAL, timeScale, value));
var timerDelta = (timeScale, value = 0) => nodeObject(new TimerNode_default(TimerNode_default.DELTA, timeScale, value));
var range = (min2, max2) => nodeObject(new RangeNode_default(min2, max2));
var checker = nodeProxy(CheckerNode_default);
var fog = nodeProxy(FogNode_default);
var rangeFog = nodeProxy(FogRangeNode_default);

// node_modules/three/examples/jsm/nodes/lighting/AnalyticLightNode.js
var AnalyticLightNode = class extends LightingNode_default {
  constructor(light = null) {
    super();
    this.updateType = NodeUpdateType.Object;
    this.light = light;
    this.colorNode = uniform(new Color());
  }
  getHash() {
    return this.light.uuid;
  }
  update() {
    const { light } = this;
    this.colorNode.value.copy(light.color).multiplyScalar(light.intensity);
  }
};
var AnalyticLightNode_default = AnalyticLightNode;

// node_modules/three/examples/jsm/nodes/lighting/PunctualLightNode.js
var PunctualLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.cutoffDistanceNode = uniform(0);
    this.decayExponentNode = uniform(0);
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.cutoffDistanceNode.value = light.distance;
    this.decayExponentNode.value = light.decay;
  }
  construct(builder) {
    const { colorNode, cutoffDistanceNode, decayExponentNode } = this;
    const lightPositionViewNode = new Object3DNode_default(Object3DNode_default.VIEW_POSITION, this.light);
    const lVector = sub(lightPositionViewNode, positionView);
    const lightDirection = normalize(lVector);
    const lightDistance = length(lVector);
    const lightAttenuation = getDistanceAttenuation_default.call({
      lightDistance,
      cutoffDistance: cutoffDistanceNode,
      decayExponent: decayExponentNode
    });
    const lightColor = mul(colorNode, lightAttenuation);
    const lightingModelFunctionNode = builder.context.lightingModelNode;
    const reflectedLight = builder.context.reflectedLight;
    if (lightingModelFunctionNode == null ? void 0 : lightingModelFunctionNode.direct) {
      lightingModelFunctionNode.direct.call({
        lightDirection,
        lightColor,
        reflectedLight
      }, builder);
    }
  }
};
LightsNode_default.setReference(PointLight, PunctualLightNode);
var PunctualLightNode_default = PunctualLightNode;

// node_modules/three/examples/jsm/nodes/lighting/HemisphereLightNode.js
var HemisphereLightNode = class extends AnalyticLightNode_default {
  constructor(light = null) {
    super(light);
    this.lightPositionNode = new Object3DNode_default(Object3DNode_default.POSITION);
    this.lightDirectionNode = normalize(this.lightPositionNode);
    this.groundColorNode = uniform(new Color());
  }
  update(frame) {
    const { light } = this;
    super.update(frame);
    this.lightPositionNode.object3d = light;
    this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity);
  }
  generate(builder) {
    const { colorNode, groundColorNode, lightDirectionNode } = this;
    const dotNL = dot(normalView, lightDirectionNode);
    const hemiDiffuseWeight = add(mul(0.5, dotNL), 0.5);
    const irradiance = mix(groundColorNode, colorNode, hemiDiffuseWeight);
    builder.context.irradiance.add(irradiance);
  }
};
LightsNode_default.setReference(HemisphereLight, HemisphereLightNode);
var HemisphereLightNode_default = HemisphereLightNode;

// node_modules/three/examples/jsm/nodes/lighting/EnvironmentNode.js
var getSpecularMIPLevel = new ShaderNode(({ texture: texture2, levelNode }) => {
  const maxMIPLevelScalar = new MaxMipLevelNode_default(texture2);
  const sigma = div(mul(Math.PI, mul(levelNode, levelNode)), add(1, levelNode));
  const desiredMIPLevel = add(maxMIPLevelScalar, log2(sigma));
  return clamp(desiredMIPLevel, 0, maxMIPLevelScalar);
});
var EnvironmentNode = class extends LightingNode_default {
  constructor(envNode = null) {
    super();
    this.envNode = envNode;
  }
  construct(builder) {
    const envNode = this.envNode;
    const properties = builder.getNodeProperties(this);
    let reflectVec = reflect(negate(positionViewDirection), transformedNormalView);
    reflectVec = normalize(mix(reflectVec, transformedNormalView, mul(roughness, roughness)));
    reflectVec = transformDirection(reflectVec, cameraViewMatrix);
    const radianceContext = new ContextNode_default(envNode, {
      tempRead: false,
      uvNode: reflectVec,
      levelNode: roughness,
      levelShaderNode: getSpecularMIPLevel
    });
    const irradianceContext = new ContextNode_default(envNode, {
      tempRead: false,
      uvNode: transformedNormalWorld,
      levelNode: float(1),
      levelShaderNode: getSpecularMIPLevel
    });
    radianceContext.context.environmentContext = radianceContext;
    irradianceContext.context.environmentContext = irradianceContext;
    builder.context.radiance.add(radianceContext);
    builder.context.iblIrradiance.add(mul(Math.PI, irradianceContext));
    properties.radianceContext = radianceContext;
    properties.irradianceContext = irradianceContext;
  }
};
var EnvironmentNode_default = EnvironmentNode;

// node_modules/three/examples/jsm/nodes/lighting/AONode.js
var AONode = class extends LightingNode_default {
  constructor(aoNode = null) {
    super();
    this.aoNode = aoNode;
  }
  construct(builder) {
    const aoIntensity = 1;
    const aoNode = add(mul(sub(float(this.aoNode), 1), aoIntensity), 1);
    builder.context.ambientOcclusion.mul(aoNode);
  }
};
var AONode_default = AONode;

// node_modules/three/examples/jsm/nodes/loaders/NodeLoader.js
var NodeLoader = class extends Loader {
  constructor(manager) {
    super(manager);
    this.textures = {};
  }
  load(url, onLoad, onProgress, onError) {
    const loader = new FileLoader(this.manager);
    loader.setPath(this.path);
    loader.setRequestHeader(this.requestHeader);
    loader.setWithCredentials(this.withCredentials);
    loader.load(url, (text) => {
      try {
        onLoad(this.parse(JSON.parse(text)));
      } catch (e) {
        if (onError) {
          onError(e);
        } else {
          console.error(e);
        }
        this.manager.itemError(url);
      }
    }, onProgress, onError);
  }
  parseNodes(json) {
    const nodes = {};
    if (json !== void 0) {
      for (const nodeJSON of json) {
        const { uuid, type } = nodeJSON;
        nodes[uuid] = fromType(type);
        nodes[uuid].uuid = uuid;
      }
      const meta = { nodes, textures: this.textures };
      for (const nodeJSON of json) {
        nodeJSON.meta = meta;
        const node = nodes[nodeJSON.uuid];
        node.deserialize(nodeJSON);
        delete nodeJSON.meta;
      }
    }
    return nodes;
  }
  parse(json) {
    const node = fromType(json.type);
    node.uuid = json.uuid;
    const nodes = this.parseNodes(json.inputNodes);
    const meta = { nodes, textures: this.textures };
    json.meta = meta;
    node.deserialize(json);
    delete json.meta;
    return node;
  }
  setTextures(value) {
    this.textures = value;
    return this;
  }
};
var NodeLoader_default = NodeLoader;

// node_modules/three/examples/jsm/nodes/materials/NodeMaterial.js
var NodeMaterial = class extends ShaderMaterial {
  constructor() {
    super();
    this.isNodeMaterial = true;
    this.type = this.constructor.name;
    this.lights = true;
  }
  build(builder) {
    this.generatePosition(builder);
    const { lightsNode } = this;
    const { diffuseColorNode } = this.generateDiffuseColor(builder);
    const outgoingLightNode = this.generateLight(builder, { diffuseColorNode, lightsNode });
    this.generateOutput(builder, { diffuseColorNode, outgoingLightNode });
  }
  customProgramCacheKey() {
    return this.uuid + "-" + this.version;
  }
  generatePosition(builder) {
    var _a;
    const object = builder.object;
    let vertex = positionLocal;
    if (this.positionNode !== null) {
      vertex = bypass(vertex, assign(positionLocal, this.positionNode));
    }
    if (((_a = object.instanceMatrix) == null ? void 0 : _a.isInstancedBufferAttribute) === true && builder.isAvailable("instance") === true) {
      vertex = bypass(vertex, instance(object));
    }
    if (object.isSkinnedMesh === true) {
      vertex = bypass(vertex, skinning(object));
    }
    builder.context.vertex = vertex;
    builder.addFlow("vertex", modelViewProjection());
  }
  generateDiffuseColor(builder) {
    let colorNode = vec4(this.colorNode || materialColor);
    let opacityNode = this.opacityNode ? float(this.opacityNode) : materialOpacity;
    colorNode = builder.addFlow("fragment", label(colorNode, "Color"));
    const diffuseColorNode = builder.addFlow("fragment", label(colorNode, "DiffuseColor"));
    opacityNode = builder.addFlow("fragment", label(opacityNode, "OPACITY"));
    builder.addFlow("fragment", assign(diffuseColorNode.a, mul(diffuseColorNode.a, opacityNode)));
    if (this.alphaTestNode || this.alphaTest > 0) {
      const alphaTestNode = this.alphaTestNode ? float(this.alphaTestNode) : materialAlphaTest;
      builder.addFlow("fragment", label(alphaTestNode, "AlphaTest"));
      builder.addFlow("fragment", new ExpressionNode_default("if ( DiffuseColor.a <= AlphaTest ) { discard; }"));
    }
    return { colorNode, diffuseColorNode };
  }
  generateLight(builder, { diffuseColorNode, lightingModelNode, lightsNode = builder.lightsNode }) {
    let outgoingLightNode = diffuseColorNode.xyz;
    if (lightsNode && lightsNode.hasLight !== false)
      outgoingLightNode = builder.addFlow("fragment", label(lightingContext(lightsNode, lightingModelNode), "Light"));
    return outgoingLightNode;
  }
  generateOutput(builder, { diffuseColorNode, outgoingLightNode }) {
    let outputNode = vec4(outgoingLightNode, diffuseColorNode.a);
    outputNode = colorSpace(outputNode, builder.renderer.outputEncoding);
    if (builder.fogNode)
      outputNode = vec4(vec3(builder.fogNode.mix(outputNode)), outputNode.w);
    builder.addFlow("fragment", label(outputNode, "Output"));
    return outputNode;
  }
  setDefaultValues(values) {
    var _a;
    for (const property2 in values) {
      const value = values[property2];
      if (this[property2] === void 0) {
        this[property2] = ((_a = value == null ? void 0 : value.clone) == null ? void 0 : _a.call(value)) || value;
      }
    }
    Object.assign(this.defines, values.defines);
  }
  toJSON(meta) {
    const isRoot = meta === void 0 || typeof meta === "string";
    if (isRoot) {
      meta = {
        textures: {},
        images: {},
        nodes: {}
      };
    }
    const data = Material.prototype.toJSON.call(this, meta);
    const nodeKeys = getNodesKeys(this);
    data.inputNodes = {};
    for (const name of nodeKeys) {
      data.inputNodes[name] = this[name].toJSON(meta).uuid;
    }
    function extractFromCache(cache) {
      const values = [];
      for (const key in cache) {
        const data2 = cache[key];
        delete data2.metadata;
        values.push(data2);
      }
      return values;
    }
    if (isRoot) {
      const textures = extractFromCache(meta.textures);
      const images = extractFromCache(meta.images);
      const nodes = extractFromCache(meta.nodes);
      if (textures.length > 0)
        data.textures = textures;
      if (images.length > 0)
        data.images = images;
      if (nodes.length > 0)
        data.nodes = nodes;
    }
    return data;
  }
  static fromMaterial() {
  }
};
var NodeMaterial_default = NodeMaterial;

// node_modules/three/examples/jsm/nodes/materials/LineBasicNodeMaterial.js
var defaultValues = new LineBasicMaterial();
var LineBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isLineBasicNodeMaterial = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var LineBasicNodeMaterial_default = LineBasicNodeMaterial;

// node_modules/three/examples/jsm/nodes/materials/MeshBasicNodeMaterial.js
var defaultValues2 = new MeshBasicMaterial();
var MeshBasicNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshBasicNodeMaterial = true;
    this.lights = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues2);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var MeshBasicNodeMaterial_default = MeshBasicNodeMaterial;

// node_modules/three/examples/jsm/nodes/materials/MeshStandardNodeMaterial.js
var defaultValues3 = new MeshStandardMaterial();
var MeshStandardNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isMeshStandardNodeMaterial = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.normalNode = null;
    this.emissiveNode = null;
    this.metalnessNode = null;
    this.roughnessNode = null;
    this.envNode = null;
    this.lightsNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues3);
    this.setValues(parameters);
  }
  build(builder) {
    this.generatePosition(builder);
    const colorNodes = this.generateDiffuseColor(builder);
    const { colorNode } = colorNodes;
    let { diffuseColorNode } = colorNodes;
    const envNode = this.envNode || builder.scene.environmentNode;
    diffuseColorNode = this.generateStandardMaterial(builder, { colorNode, diffuseColorNode });
    if (this.lightsNode)
      builder.lightsNode = this.lightsNode;
    const materialLightsNode = [];
    if (envNode) {
      materialLightsNode.push(new EnvironmentNode_default(envNode));
    }
    if (builder.material.aoMap) {
      materialLightsNode.push(new AONode_default(texture(builder.material.aoMap)));
    }
    if (materialLightsNode.length > 0) {
      builder.lightsNode = new LightsNode_default([...builder.lightsNode.lightNodes, ...materialLightsNode]);
    }
    const outgoingLightNode = this.generateLight(builder, { diffuseColorNode, lightingModelNode: PhysicalLightingModel_default });
    this.generateOutput(builder, { diffuseColorNode, outgoingLightNode });
  }
  generateStandardMaterial(builder, { colorNode, diffuseColorNode }) {
    const { material } = builder;
    let metalnessNode = this.metalnessNode ? float(this.metalnessNode) : materialMetalness;
    metalnessNode = builder.addFlow("fragment", label(metalnessNode, "Metalness"));
    builder.addFlow("fragment", assign(diffuseColorNode, vec4(mul(diffuseColorNode.rgb, invert(metalnessNode)), diffuseColorNode.a)));
    let roughnessNode = this.roughnessNode ? float(this.roughnessNode) : materialRoughness;
    roughnessNode = getRoughness_default.call({ roughness: roughnessNode });
    builder.addFlow("fragment", label(roughnessNode, "Roughness"));
    const specularColorNode = mix(vec3(0.04), colorNode.rgb, metalnessNode);
    builder.addFlow("fragment", label(specularColorNode, "SpecularColor"));
    const normalNode = this.normalNode ? vec3(this.normalNode) : material.normalMap ? new NormalMapNode_default(texture(material.normalMap), uniform(material.normalScale)) : normalView;
    builder.addFlow("fragment", label(normalNode, "TransformedNormalView"));
    return diffuseColorNode;
  }
  generateLight(builder, { diffuseColorNode, lightingModelNode, lightsNode = builder.lightsNode }) {
    const renderer = builder.renderer;
    let outgoingLightNode = super.generateLight(builder, { diffuseColorNode, lightingModelNode, lightsNode });
    outgoingLightNode = add(vec3(this.emissiveNode || materialEmissive), outgoingLightNode);
    if (renderer.toneMappingNode)
      outgoingLightNode = context(renderer.toneMappingNode, { color: outgoingLightNode });
    return outgoingLightNode;
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.normalNode = source.normalNode;
    this.emissiveNode = source.emissiveNode;
    this.metalnessNode = source.metalnessNode;
    this.roughnessNode = source.roughnessNode;
    this.envNode = source.envNode;
    this.lightsNode = source.lightsNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};

// node_modules/three/examples/jsm/nodes/materials/MeshPhysicalNodeMaterial.js
var defaultValues4 = new MeshPhysicalMaterial();
var MeshPhysicalNodeMaterial = class extends MeshStandardNodeMaterial {
  constructor(parameters) {
    super();
    this.isMeshPhysicalNodeMaterial = true;
    this.clearcoatNode = null;
    this.clearcoatRoughnessNode = null;
    this.clearcoatNormalNode = null;
    this.sheenNode = null;
    this.sheenRoughnessNode = null;
    this.sheen = 0;
    this.clearcoat = 0;
    this.iridescence = 0;
    this.transmission = 0;
    this.setDefaultValues(defaultValues4);
    this.setValues(parameters);
  }
  copy(source) {
    this.clearcoatNode = source.clearcoatNode;
    this.clearcoatRoughnessNode = source.clearcoatRoughnessNode;
    this.clearcoatNormalNode = source.clearcoatNormalNode;
    this.sheenNode = source.sheenNode;
    this.sheenRoughnessNode = source.sheenRoughnessNode;
    return super.copy(source);
  }
};

// node_modules/three/examples/jsm/nodes/materials/PointsNodeMaterial.js
var defaultValues5 = new PointsMaterial();
var PointsNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isPointsNodeMaterial = true;
    this.transparent = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.sizeNode = null;
    this.positionNode = null;
    this.setDefaultValues(defaultValues5);
    this.setValues(parameters);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.sizeNode = source.sizeNode;
    this.positionNode = source.positionNode;
    return super.copy(source);
  }
};
var PointsNodeMaterial_default = PointsNodeMaterial;

// node_modules/three/examples/jsm/nodes/materials/SpriteNodeMaterial.js
var defaultValues6 = new SpriteMaterial();
var SpriteNodeMaterial = class extends NodeMaterial_default {
  constructor(parameters) {
    super();
    this.isSpriteNodeMaterial = true;
    this.lights = true;
    this.colorNode = null;
    this.opacityNode = null;
    this.alphaTestNode = null;
    this.lightNode = null;
    this.positionNode = null;
    this.rotationNode = null;
    this.scaleNode = null;
    this.setDefaultValues(defaultValues6);
    this.setValues(parameters);
  }
  generatePosition(builder) {
    var _a;
    const { positionNode, rotationNode, scaleNode } = this;
    const vertex = positionLocal;
    let mvPosition = mul(modelViewMatrix, positionNode ? vec4(positionNode.xyz, 1) : vec4(0, 0, 0, 1));
    let scale = vec2(
      length(vec3(modelWorldMatrix[0].x, modelWorldMatrix[0].y, modelWorldMatrix[0].z)),
      length(vec3(modelWorldMatrix[1].x, modelWorldMatrix[1].y, modelWorldMatrix[1].z))
    );
    if (scaleNode !== null) {
      scale = mul(scale, scaleNode);
    }
    let alignedPosition = vertex.xy;
    if (((_a = builder.object.center) == null ? void 0 : _a.isVector2) === true) {
      alignedPosition = sub(alignedPosition, sub(uniform(builder.object.center), vec2(0.5)));
    }
    alignedPosition = mul(alignedPosition, scale);
    const rotation = rotationNode || materialRotation;
    const rotatedPosition = vec2(
      sub(mul(cos(rotation), alignedPosition.x), mul(sin(rotation), alignedPosition.y)),
      add(mul(sin(rotation), alignedPosition.x), mul(cos(rotation), alignedPosition.y))
    );
    mvPosition = vec4(add(mvPosition.xy, rotatedPosition.xy), mvPosition.z, mvPosition.w);
    const modelViewProjection2 = mul(cameraProjectionMatrix, mvPosition);
    builder.context.vertex = vertex;
    builder.addFlow("vertex", modelViewProjection2);
  }
  copy(source) {
    this.colorNode = source.colorNode;
    this.opacityNode = source.opacityNode;
    this.alphaTestNode = source.alphaTestNode;
    this.lightNode = source.lightNode;
    this.positionNode = source.positionNode;
    this.rotationNode = source.rotationNode;
    this.scaleNode = source.scaleNode;
    return super.copy(source);
  }
};
var SpriteNodeMaterial_default = SpriteNodeMaterial;

// node_modules/three/examples/jsm/nodes/materials/Materials.js
NodeMaterial_default.fromMaterial = function(material) {
  const materialLib = {
    NodeMaterial: NodeMaterial_default,
    LineBasicNodeMaterial: LineBasicNodeMaterial_default,
    MeshBasicNodeMaterial: MeshBasicNodeMaterial_default,
    MeshStandardNodeMaterial,
    MeshPhysicalNodeMaterial,
    PointsNodeMaterial: PointsNodeMaterial_default,
    SpriteNodeMaterial: SpriteNodeMaterial_default
  };
  const type = material.type.replace("Material", "NodeMaterial");
  if (materialLib[type] === void 0) {
    return material;
  }
  const nodeMaterial = new materialLib[type](material);
  for (const key in material) {
    if (nodeMaterial[key] === void 0) {
      nodeMaterial[key] = material[key];
    }
  }
  return nodeMaterial;
};

// node_modules/three/examples/jsm/nodes/loaders/NodeMaterialLoader.js
var superFromTypeFunction = MaterialLoader.createMaterialFromType;
MaterialLoader.createMaterialFromType = function(type) {
  const materialLib = {
    NodeMaterial: NodeMaterial_default,
    LineBasicNodeMaterial: LineBasicNodeMaterial_default,
    MeshBasicNodeMaterial: MeshBasicNodeMaterial_default,
    MeshStandardNodeMaterial,
    PointsNodeMaterial: PointsNodeMaterial_default,
    SpriteNodeMaterial: SpriteNodeMaterial_default
  };
  if (materialLib[type] !== void 0) {
    return new materialLib[type]();
  }
  return superFromTypeFunction.call(this, type);
};
var NodeMaterialLoader = class extends MaterialLoader {
  constructor(manager) {
    super(manager);
    this.nodes = {};
  }
  parse(json) {
    const material = super.parse(json);
    const nodes = this.nodes;
    const inputNodes = json.inputNodes;
    for (const property2 in inputNodes) {
      const uuid = inputNodes[property2];
      material[property2] = nodes[uuid];
    }
    return material;
  }
  setNodes(value) {
    this.nodes = value;
    return this;
  }
};
var NodeMaterialLoader_default = NodeMaterialLoader;

// node_modules/three/examples/jsm/nodes/loaders/NodeObjectLoader.js
var NodeObjectLoader = class extends ObjectLoader {
  constructor(manager) {
    super(manager);
    this._nodesJSON = null;
  }
  parse(json, onLoad) {
    this._nodesJSON = json.nodes;
    const data = super.parse(json, onLoad);
    this._nodesJSON = null;
    return data;
  }
  parseNodes(json, textures) {
    if (json !== void 0) {
      const loader = new NodeLoader_default();
      loader.setTextures(textures);
      return loader.parseNodes(json);
    }
    return {};
  }
  parseMaterials(json, textures) {
    const materials = {};
    if (json !== void 0) {
      const nodes = this.parseNodes(this._nodesJSON, textures);
      const loader = new NodeMaterialLoader_default();
      loader.setTextures(textures);
      loader.setNodes(nodes);
      for (let i = 0, l = json.length; i < l; i++) {
        const data = json[i];
        materials[data.uuid] = loader.parse(data);
      }
    }
    return materials;
  }
};
var NodeObjectLoader_default = NodeObjectLoader;

// node_modules/three/examples/jsm/nodes/Nodes.js
var nodeLib = {
  // core
  ArrayUniformNode: ArrayUniformNode_default,
  AttributeNode: AttributeNode_default,
  BypassNode: BypassNode_default,
  CodeNode: CodeNode_default,
  ContextNode: ContextNode_default,
  ConstNode: ConstNode_default,
  ExpressionNode: ExpressionNode_default,
  FunctionCallNode: FunctionCallNode_default,
  FunctionNode: FunctionNode_default,
  InstanceIndexNode: InstanceIndexNode_default,
  Node: Node_default,
  NodeAttribute: NodeAttribute_default,
  NodeBuilder: NodeBuilder_default,
  NodeCode: NodeCode_default,
  NodeFrame: NodeFrame_default,
  NodeFunctionInput: NodeFunctionInput_default,
  NodeKeywords: NodeKeywords_default,
  NodeUniform: NodeUniform_default,
  NodeVar: NodeVar_default,
  NodeVarying: NodeVarying_default,
  PropertyNode: PropertyNode_default,
  TempNode: TempNode_default,
  UniformNode: UniformNode_default,
  VarNode: VarNode_default,
  VaryingNode: VaryingNode_default,
  // geometry
  RangeNode: RangeNode_default,
  // gpgpu
  ComputeNode: ComputeNode_default,
  // accessors
  BufferNode: BufferNode_default,
  CameraNode: CameraNode_default,
  CubeTextureNode: CubeTextureNode_default,
  InstanceNode: InstanceNode_default,
  MaterialNode: MaterialNode_default,
  MaterialReferenceNode: MaterialReferenceNode_default,
  ModelNode: ModelNode_default,
  ModelViewProjectionNode: ModelViewProjectionNode_default,
  NormalNode: NormalNode_default,
  Object3DNode: Object3DNode_default,
  PointUVNode: PointUVNode_default,
  PositionNode: PositionNode_default,
  ReferenceNode: ReferenceNode_default,
  ReflectVectorNode: ReflectVectorNode_default,
  SkinningNode: SkinningNode_default,
  TextureNode: TextureNode_default,
  UVNode: UVNode_default,
  UserDataNode: UserDataNode_default,
  // display
  ColorAdjustmentNode: ColorAdjustmentNode_default,
  ColorSpaceNode: ColorSpaceNode_default,
  FrontFacingNode: FrontFacingNode_default,
  NormalMapNode: NormalMapNode_default,
  ToneMappingNode: ToneMappingNode_default,
  // math
  MathNode: MathNode_default,
  OperatorNode: OperatorNode_default,
  CondNode: CondNode_default,
  // lighting
  PunctualLightNode: PunctualLightNode_default,
  LightsNode: LightsNode_default,
  LightingNode: LightingNode_default,
  LightingContextNode: LightingContextNode_default,
  HemisphereLightNode: HemisphereLightNode_default,
  EnvironmentNode: EnvironmentNode_default,
  AONode: AONode_default,
  AnalyticLightNode: AnalyticLightNode_default,
  // utils
  ArrayElementNode: ArrayElementNode_default,
  ConvertNode: ConvertNode_default,
  JoinNode: JoinNode_default,
  MatcapUVNode: MatcapUVNode_default,
  MaxMipLevelNode: MaxMipLevelNode_default,
  OscNode: OscNode_default,
  RotateUVNode: RotateUVNode_default,
  SplitNode: SplitNode_default,
  SpriteSheetUVNode: SpriteSheetUVNode_default,
  TimerNode: TimerNode_default,
  // procedural
  CheckerNode: CheckerNode_default,
  // fog
  FogNode: FogNode_default,
  FogRangeNode: FogRangeNode_default,
  // loaders
  NodeLoader: NodeLoader_default,
  NodeObjectLoader: NodeObjectLoader_default,
  NodeMaterialLoader: NodeMaterialLoader_default
};
var fromType = (type) => {
  return new nodeLib[type]();
};
export {
  AONode_default as AONode,
  AnalyticLightNode_default as AnalyticLightNode,
  ArrayElementNode_default as ArrayElementNode,
  ArrayUniformNode_default as ArrayUniformNode,
  AttributeNode_default as AttributeNode,
  BRDF_GGX_default as BRDF_GGX,
  BRDF_Lambert_default as BRDF_Lambert,
  BufferNode_default as BufferNode,
  BypassNode_default as BypassNode,
  CameraNode_default as CameraNode,
  CheckerNode_default as CheckerNode,
  CodeNode_default as CodeNode,
  ColorAdjustmentNode_default as ColorAdjustmentNode,
  ColorSpaceNode_default as ColorSpaceNode,
  ComputeNode_default as ComputeNode,
  CondNode_default as CondNode,
  ConstNode_default as ConstNode,
  ContextNode_default as ContextNode,
  ConvertNode_default as ConvertNode,
  CubeTextureNode_default as CubeTextureNode,
  DFGApprox_default as DFGApprox,
  D_GGX_default as D_GGX,
  EPSILON,
  EnvironmentNode_default as EnvironmentNode,
  ExpressionNode_default as ExpressionNode,
  F_Schlick_default as F_Schlick,
  FogNode_default as FogNode,
  FogRangeNode_default as FogRangeNode,
  FrontFacingNode_default as FrontFacingNode,
  FunctionCallNode_default as FunctionCallNode,
  FunctionNode_default as FunctionNode,
  HemisphereLightNode_default as HemisphereLightNode,
  INFINITY,
  InstanceIndexNode_default as InstanceIndexNode,
  InstanceNode_default as InstanceNode,
  JoinNode_default as JoinNode,
  LightingContextNode_default as LightingContextNode,
  LightingNode_default as LightingNode,
  LightsNode_default as LightsNode,
  LineBasicNodeMaterial_default as LineBasicNodeMaterial,
  MatcapUVNode_default as MatcapUVNode,
  MaterialNode_default as MaterialNode,
  MaterialReferenceNode_default as MaterialReferenceNode,
  MathNode_default as MathNode,
  MaxMipLevelNode_default as MaxMipLevelNode,
  MeshBasicNodeMaterial_default as MeshBasicNodeMaterial,
  MeshPhysicalNodeMaterial,
  MeshStandardNodeMaterial,
  ModelNode_default as ModelNode,
  ModelViewProjectionNode_default as ModelViewProjectionNode,
  Node_default as Node,
  NodeAttribute_default as NodeAttribute,
  NodeBuilder_default as NodeBuilder,
  NodeCode_default as NodeCode,
  NodeFrame_default as NodeFrame,
  NodeFunctionInput_default as NodeFunctionInput,
  NodeKeywords_default as NodeKeywords,
  NodeLoader_default as NodeLoader,
  NodeMaterial_default as NodeMaterial,
  NodeMaterialLoader_default as NodeMaterialLoader,
  NodeObjectLoader_default as NodeObjectLoader,
  NodeShaderStage,
  NodeType,
  NodeUniform_default as NodeUniform,
  NodeUpdateType,
  NodeVar_default as NodeVar,
  NodeVarying_default as NodeVarying,
  NormalMapNode_default as NormalMapNode,
  NormalNode_default as NormalNode,
  Object3DNode_default as Object3DNode,
  OperatorNode_default as OperatorNode,
  OscNode_default as OscNode,
  PhysicalLightingModel_default as PhysicalLightingModel,
  PointUVNode_default as PointUVNode,
  PointsNodeMaterial_default as PointsNodeMaterial,
  PositionNode_default as PositionNode,
  PropertyNode_default as PropertyNode,
  PunctualLightNode_default as PunctualLightNode,
  RangeNode_default as RangeNode,
  ReferenceNode_default as ReferenceNode,
  ReflectVectorNode_default as ReflectVectorNode,
  RotateUVNode_default as RotateUVNode,
  ShaderNode,
  SkinningNode_default as SkinningNode,
  SplitNode_default as SplitNode,
  SpriteNodeMaterial_default as SpriteNodeMaterial,
  SpriteSheetUVNode_default as SpriteSheetUVNode,
  TempNode_default as TempNode,
  TextureNode_default as TextureNode,
  TimerNode_default as TimerNode,
  ToneMappingNode_default as ToneMappingNode,
  UVNode_default as UVNode,
  UniformNode_default as UniformNode,
  UserDataNode_default as UserDataNode,
  V_GGX_SmithCorrelated_default as V_GGX_SmithCorrelated,
  VarNode_default as VarNode,
  VaryingNode_default as VaryingNode,
  abs,
  acos,
  add,
  alphaTest,
  and,
  asin,
  assign,
  atan,
  atan2,
  attribute,
  bitAnd,
  bitOr,
  bitXor,
  bmat3,
  bmat4,
  bool,
  buffer,
  bvec2,
  bvec3,
  bvec4,
  bypass,
  call,
  cameraNormalMatrix,
  cameraPosition,
  cameraProjectionMatrix,
  cameraViewMatrix,
  cameraWorldMatrix,
  ceil,
  checker,
  clamp,
  code,
  color,
  colorSpace,
  compute,
  cond,
  context,
  cos,
  cross,
  cubeTexture,
  dFdx,
  dFdy,
  degrees,
  diffuseColor,
  distance,
  div,
  dot,
  dotNV,
  element,
  equal,
  exp,
  exp2,
  expression,
  faceDirection,
  faceforward,
  float,
  floor,
  fog,
  fract,
  fromType,
  frontFacing,
  func,
  getDistanceAttenuation_default as getDistanceAttenuation,
  getGeometryRoughness_default as getGeometryRoughness,
  getRoughness_default as getRoughness,
  greaterThan,
  greaterThanEqual,
  hue,
  imat3,
  imat4,
  instance,
  instanceIndex,
  int,
  inversesqrt,
  invert,
  ivec2,
  ivec3,
  ivec4,
  label,
  length,
  lessThan,
  lessThanEqual,
  lightingContext,
  lights,
  log,
  log2,
  mat3,
  mat4,
  matcapUV,
  materialAlphaTest,
  materialColor,
  materialEmissive,
  materialMetalness,
  materialOpacity,
  materialReference,
  materialRotation,
  materialRoughness,
  max,
  maxMipLevel,
  metalness,
  min,
  mix,
  mod,
  modelNormalMatrix,
  modelPosition,
  modelViewMatrix,
  modelViewPosition,
  modelViewProjection,
  modelWorldMatrix,
  mul,
  negate,
  nodeArray,
  nodeImmutable,
  nodeObject,
  nodeObjects,
  nodeProxy,
  normalGeometry,
  normalLocal,
  normalMap,
  normalView,
  normalWorld,
  normalize,
  or,
  oscSawtooth,
  oscSine,
  oscSquare,
  oscTriangle,
  pointUV,
  positionGeometry,
  positionLocal,
  positionView,
  positionViewDirection,
  positionWorld,
  pow,
  pow2,
  pow3,
  pow4,
  property,
  radians,
  range,
  rangeFog,
  reference,
  reflect,
  reflectVector,
  refract,
  remainder,
  rotateUV,
  roughness,
  round,
  sampler,
  saturate,
  saturation,
  shiftLeft,
  shiftRight,
  sign,
  sin,
  skinning,
  smoothstep,
  specularColor,
  spritesheetUV,
  sqrt,
  step,
  storage,
  sub,
  tan,
  temp,
  texture,
  timerDelta,
  timerGlobal,
  timerLocal,
  toneMapping,
  transformDirection,
  transformedNormalView,
  transformedNormalWorld,
  uint,
  umat3,
  umat4,
  uniform,
  userData,
  uv,
  uvec2,
  uvec3,
  uvec4,
  varying,
  vec2,
  vec3,
  vec4,
  vibrance,
  xor
};
//# sourceMappingURL=three_examples_jsm_nodes_Nodes__js.js.map
